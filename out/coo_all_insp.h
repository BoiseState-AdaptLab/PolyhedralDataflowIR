// 'coo_all_insp' code generated by 'edavis' at 11/20/2019 08:48:34
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <string.h>

#define min(x,y) (((x)<(y))?(x):(y))
#define max(x,y) (((x)>(y))?(x):(y))
#define abs(x) ((x)<0?-(x):(x))
#define absmin(x,y) ((x)=min(abs((x)),abs((y))))
#define absmax(x,y) ((x)=max(abs((x)),abs((y))))
#define floord(x,y) ((x)/(y))
#define sgn(x) ((x)<0?-1:1)
#define offset2(i,j,M) ((j)+(i)*(M))
#define offset3(i,j,k,M,N) ((k)+((j)+(i)*(M))*(N))
#define offset4(i,j,k,l,M,N,P) ((l)+((k)+((j)+(i)*(M))*(N))*(P))
#define arrinit(ptr,val,size) for(unsigned __i__=0;__i__<(size);__i__++) (ptr)[__i__]=(val)
#define arrprnt(name,arr,size) {\
fprintf(stderr,"%s={",(name));\
for(unsigned __i__=0;__i__<(size);__i__++) fprintf(stderr,"%lg,",(arr)[__i__]);\
fprintf(stderr,"}\n");}
#define row(n) row[(n)]
#define row(n) row[(n)]
#define rp(i) (*rp)[(i)]

unsigned coo_all_insp(const unsigned M, const unsigned* row, const unsigned* col, const double* val,
                       unsigned* NB, unsigned* K, unsigned** rp, unsigned** crow, unsigned** crp, unsigned** lcol, double** lval);
inline unsigned coo_all_insp(const unsigned M, const unsigned* row, const unsigned* col, const double* val, unsigned* NB, unsigned* K,
                             unsigned** rp, unsigned** crow, unsigned** crp, unsigned** lcol, double** lval) {
    unsigned t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15;
    unsigned N,B=128;
    unsigned K=0,Kest,size;
    unsigned R=0;
    unsigned i,n,j,k,bi,bj,b;

N=row(M-1)+1;
*rp=(unsigned*) calloc(N+1,sizeof(unsigned));
*crow = (unsigned*) calloc(M, sizeof(unsigned));
*crp = (unsigned*) calloc(N+1, sizeof(unsigned));

rp(row(0))++;
#pragma omp parallel for
for(n = 1; n < M; n++) {
  i = row(n);
  rp(i+1)++;

  if ((i) != row(n-1)) R+=1;
  (*crow)[R] = i;
  if (n >= (*crp)[R+1]) (*crp)[R+1]=n+1;

  bi = row[n]/B;
  bj = col[n]/B;
  b = bnum(bi,bj);
  bmap[b][bcnt[b]++] = n;
  if (b >= *NB) *NB = b+1;
  brow[b] = bi;
  bcol[b] = bj;
}

#pragma omp parallel for schedule(auto)
for(i = 0; i < N; i++) {
  *K = max(*K,rp(i+1));
  rp(i+1) += rp(i);
}

*lcol = (unsigned*) calloc(N * (*K), sizeof(int));
*lval = (double*) calloc(N * (*K), sizeof(double));

#pragma omp parallel for schedule(auto)
for(i = 0; i < N; i++) {
  #pragma omp simd
  for (n = rp(i); n < rp(i+1); i++) {
    k = n - rp(i);
    (*lcol)[i*(*K)+k] = col[n];
    (*lval)[i*(*K)+k] = val[n];
  }
}

R += 1;
*crow = (unsigned*) realloc(*crow, R * sizeof(int));
*crp = (unsigned*) realloc(*crp, (R+1) * sizeof(int));

*brow = (unsigned*) realloc(*brow, *NB * sizeof(int));
*bcol = (unsigned*) realloc(*bcol, *NB * sizeof(int));
*bp = (unsigned*) realloc(*bp, (*NB+1) * sizeof(int));

  #pragma omp parallel for schedule(auto)
  for (b = 0; b < nb; b++) {
    #pragma omp simd
    for (p = 0; p < bcnt[b]; p++) {
      n = bmap[b][p];
      erow[p] = row[n] - B * brow[b];
      ecol[p] = col]n] - B * bcol[b];
      if (p >= bp(b+1)) bp(b+1) = p+1;
      bval[p] = val[n];
    }
  }

    return (N);
}    // coo_csr_insp

#undef min
#undef max
#undef abs
#undef absmin
#undef absmax
#undef floord
#undef sgn
#undef offset2
#undef offset3
#undef offset4
#undef arrinit
#undef arrprnt
#undef row
#undef rp

