// 'coo_hicoo_insp' code generated by 'edavis' at 08/30/2019 16:39:20
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <string.h>
#include <assert.h>

#define min(x,y) (((x)<(y))?(x):(y))
#define max(x,y) (((x)>(y))?(x):(y))
#define abs(x) ((x)<0?-(x):(x))
#define absmin(x,y) ((x)=min(abs((x)),abs((y))))
#define absmax(x,y) ((x)=max(abs((x)),abs((y))))
#define floord(x,y) ((x)/(y))
#define sgn(x) ((x)<0?-1:1)
#define offset2(i,j,M) ((j)+(i)*(M))
#define offset3(i,j,k,M,N) ((k)+((j)+(i)*(M))*(N))
#define offset4(i,j,k,l,M,N,P) ((l)+((k)+((j)+(i)*(M))*(N))*(P))
#define arrinit(ptr,val,size) for(unsigned __i__=0;__i__<(size);__i__++) (ptr)[__i__]=(val)
#define arrprnt(name,arr,size) {\
fprintf(stderr,"%s={",(name));\
for(unsigned __i__=0;__i__<(size);__i__++) fprintf(stderr,"%lg,",(arr)[__i__]);\
fprintf(stderr,"}\n");}
#define val(n) val[(n)]
#define bval(p) (*bval)[(p)]
#define bmap(b,bi,bj,bk,m) bmap[(bi)][(bj)][(bk)][(m)]
#define bp(b) (*bp)[(b)]
#define bsize(b,bi,bj,bk) bsize[(bi)][(bj)][(bk)]
#define p(i) p
#define ind(m,n) indices[offset2((m),(n),M)]
#define ind0(m) indices[offset2(0,(m),M)]
#define ind1(m) indices[offset2(1,(m),M)]
#define ind2(m) indices[offset2(2,(m),M)]
#define bind0(b) (*bindices)[offset2((b),0,N)]
#define bind1(b) (*bindices)[offset2((b),1,N)]
#define bind2(b) (*bindices)[offset2((b),2,N)]
#define eind0(m) (*eindices)[offset2((m),0,N)]
#define eind1(m) (*eindices)[offset2((m),1,N)]
#define eind2(m) (*eindices)[offset2((m),2,N)]

#define bid(m,bi,bj,bk) {\
if(!bmap[(bi)]){\
bsize[(bi)]=(unsigned**)calloc(((J/B)+1),sizeof(unsigned*));\
bid[(bi)]=(unsigned**)calloc(((J/B)+1),sizeof(unsigned*));\
bmap[(bi)]=(unsigned***)calloc(((J/B)+1),sizeof(unsigned**));\
}\
if(!bmap[(bi)][(bj)]){\
bsize[(bi)][(bj)]=(unsigned*)calloc(((K/B)+1),sizeof(unsigned));\
bid[(bi)][(bj)]=(unsigned*)calloc(((K/B)+1),sizeof(unsigned));\
bmap[(bi)][(bj)]=(unsigned**)calloc((K/B)+1,sizeof(unsigned*));\
}\
if(!bmap[(bi)][(bj)][(bk)]){\
bid[(bi)][(bj)][(bk)]=(NB);\
bmap[(bi)][(bj)][(bk)]=(unsigned*)calloc(B*B*B,sizeof(unsigned));\
}\
b=bid[(bi)][(bj)][(bk)];\
bmap[(bi)][(bj)][(bk)][(bsize[(bi)][(bj)][(bk)])++]=(m);\
}

unsigned coo_hicoo_insp(const float* val, const unsigned B, const unsigned M, const unsigned N, const unsigned* dims, const unsigned* indices, float** bval, unsigned short** bindices, unsigned** bp, unsigned char** eindices);
inline unsigned coo_hicoo_insp(const float* val, const unsigned B, const unsigned M, const unsigned N, const unsigned* dims, const unsigned* indices, float** bval, unsigned short** bindices, unsigned** bp, unsigned char** eindices) {
    unsigned t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15;
    unsigned NB = 0;
    unsigned b = 0;
    unsigned p = 0;
    unsigned I = dims[0];
    unsigned J = dims[1];
    unsigned K = dims[2];

    //fprintf(stderr,"I=%u,J=%u,K=%u,M=%u,N=%u,B=%u\n",I,J,K,M,N,B);
    // TODO: Does 'bval' to be own space, or can we do a swap? Will that be faster or slower?
    unsigned*** bid = (unsigned***) calloc((I/B)+1,sizeof(unsigned**));
    unsigned*** bsize = (unsigned***) calloc((I/B)+1,sizeof(unsigned**));
    unsigned**** bmap = (unsigned****) calloc((I/B)+1,sizeof(unsigned***));

    *bindices = (unsigned short*) malloc(M*N*sizeof(short));
    *bp = (unsigned*) calloc(M, sizeof(int));
    *bval = (float*) malloc(M*sizeof(float));
    *eindices = (unsigned char*) malloc(M*N*sizeof(char));

    //assert(*bindices != NULL);
    //assert(*bp != NULL);
    //assert(*bval != NULL);
    //assert(*eindices != NULL);

// bs_put+br_put+bc_put+nb_cnt
#undef s0
#define s0(m,i,j,k) bid((m),(i)/B,(j)/B,(k)/B)
#undef s1
#define s1(m,i,j,k) if (b >= NB) NB=b+1
#undef s2
#define s2(m,i,j,k) bind0(b)=(i)/B
#undef s3
#define s3(m,i,j,k) bind1(b)=(j)/B
#undef s4
#define s4(m,i,j,k) bind2(b)=(k)/B

#pragma omp simd
for(t2 = 0; t2 <= M-1; t2++) {
  t4=ind0(t2);
  t6=ind1(t2);
  t8=ind2(t2);
  //fprintf(stderr,"m=%u,i=%u,j=%u,k=%u,b=%u\n",t2,t4,t6,t8,b);
  s0(t2,t4,t6,t8);
  s1(t2,t4,t6,t8);
  s2(t2,t4,t6,t8);
  s3(t2,t4,t6,t8);
  s4(t2,t4,t6,t8);
}

// bp_put+er_put+ec_put+bv_put+p_inc
#undef s0
#define s0(b,bi,bj,bk,m,n) if (p >= bp((b)+1)) bp((b)+1)=p+1
#undef s1
#define s1(b,bi,bj,bk,m,n) eind0(p)=ind0((n))-B*(bi)
#undef s2
#define s2(b,bi,bj,bk,m,n) eind1(p)=ind1((n))-B*(bj)
#undef s3
#define s3(b,bi,bj,bk,m,n) eind2(p)=ind2((n))-B*(bk)
#undef s4
#define s4(b,bi,bj,bk,m,n) bval(p)=val((n))
#undef s5
#define s5(b,bi,bj,bk,m,n) p+=1

for(t2 = 0; t2 <= NB-1; t2++) {
  t4=bind0(t2);
  t6=bind1(t2);
  t8=bind2(t2);
  #pragma omp simd
  for(t10 = 0; t10 <= bsize(t2,t4,t6,t8)-1; t10++) {
    t12=bmap(t2,t4,t6,t8,t10);
    s0(t2,t4,t6,t8,t10,t12);
    s1(t2,t4,t6,t8,t10,t12);
    s2(t2,t4,t6,t8,t10,t12);
    s3(t2,t4,t6,t8,t10,t12);
    s4(t2,t4,t6,t8,t10,t12);
    s5(t2,t4,t6,t8,t10,t12);
  }
}

  *bindices = (unsigned short*) realloc(*bindices, N * NB * sizeof(short));
  *bp = (unsigned*) realloc(*bp, (NB+1) * sizeof(int));

  // Free temporary storage
  for(t2=0;t2<=(I/B);t2++) {
    if(bmap[t2]) {
      for(t4=0;t4<=(J/B);t4++) {
        if (bmap[t2][t4]) {
          for(t6=0;t6<=(K/B);t6++) {
            if (bmap[t2][t4][t6]) {
              free(bmap[t2][t4][t6]);
            }
          }
          free(bid[t2][t4]);
          free(bsize[t2][t4]);
          free(bmap[t2][t4]);
        }
      }
      free(bmap[t2]);
      free(bid[t2]);
      free(bsize[t2]);
    }
  }
  free(bmap);
  free(bid);
  free(bsize);

  return (NB);
}    // coo_hicoo_insp

#undef min
#undef max
#undef abs
#undef absmin
#undef absmax
#undef floord
#undef sgn
#undef offset2
#undef offset3
#undef offset4
#undef arrinit
#undef arrprnt
#undef B
#undef val
#undef bmap
#undef bp
#undef bind0
#undef bind1
#undef bind2
#undef bsize
#undef p
#undef ind0
#undef ind1
#undef ind2
#undef eind0
#undef eind1
#undef eind2
