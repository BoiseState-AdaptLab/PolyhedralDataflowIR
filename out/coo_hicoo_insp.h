// 'coo_hicoo_insp' code generated by 'edavis' at 08/30/2019 16:39:20
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <string.h>

#define min(x,y) (((x)<(y))?(x):(y))
#define max(x,y) (((x)>(y))?(x):(y))
#define abs(x) ((x)<0?-(x):(x))
#define absmin(x,y) ((x)=min(abs((x)),abs((y))))
#define absmax(x,y) ((x)=max(abs((x)),abs((y))))
#define floord(x,y) ((x)/(y))
#define sgn(x) ((x)<0?-1:1)
#define offset2(i,j,M) ((j)+(i)*(M))
#define offset3(i,j,k,M,N) ((k)+((j)+(i)*(M))*(N))
#define offset4(i,j,k,l,M,N,P) ((l)+((k)+((j)+(i)*(M))*(N))*(P))
#define arrinit(ptr,val,size) for(unsigned __i__=0;__i__<(size);__i__++) (ptr)[__i__]=(val)
#define arrprnt(name,arr,size) {\
fprintf(stderr,"%s={",(name));\
for(unsigned __i__=0;__i__<(size);__i__++) fprintf(stderr,"%lg,",(arr)[__i__]);\
fprintf(stderr,"}\n");}
#define val(n) val[(n)]
#define bval(p) (*bval)[(p)]
#define bcol(b) (*bcol)[(b)]
#define bmap(b,bi,bj,m) bmap[(bi)][(bj)][(m)]
#define bp(i) (*bp)[(i)]
#define brow(b) (*brow)[(b)]
#define bsize(b,bi,bj) bsize[(bi)][(bj)]
#define col(n) col[(n)]
#define p(i) p
#define row(n) row[(n)]
#define erow(p) (*erow)[(p)]
#define ecol(p) (*ecol)[(p)]

//#define bid(n,bi,bj) {\
//if(!bmap[(bi)]){\
//bid[(bi)]=(unsigned*)calloc(((N/B)+1),sizeof(int));\
//bsize[(bi)]=(unsigned*)calloc(((N/B)+1),sizeof(int));\
//bmap[(bi)]=(unsigned**)calloc(((N/B)+1),sizeof(int*));\
//}\
//if(!bmap[(bi)][(bj)]){\
//bmap[(bi)][(bj)]=(unsigned*)calloc(B*B,sizeof(int));\
//bid[(bi)][(bj)]=(NB);\
//}\
//b=bid[(bi)][(bj)];\
//bmap[(bi)][(bj)][(bsize[(bi)][(bj)])++]=(n);\
//}

inline unsigned ilog2(unsigned x);
inline unsigned ilog2(unsigned x) {
#define clz(x) __builtin_clz((x))
    return sizeof(uint32_t) * CHAR_BIT - clz(x) - 1;
}

unsigned coo_hicoo_insp(const float* val, const unsigned B, const unsigned M, const unsigned N, const unsigned* dims, const unsigned* indices, float** bval, unsigned short** bindices, unsigned** bp, unsigned char** eindices);
inline unsigned coo_hicoo_insp(const float* val, const unsigned B, const unsigned M, const unsigned N, const unsigned* dims, const unsigned* indices, float** bval, unsigned short** bindices, unsigned** bp, unsigned char** eindices) {
    unsigned t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15;
    unsigned NB = 0;
    unsigned b = 0;
    unsigned i,m,n,p = 0;
    unsigned char e;
    unsigned char bits;

    // TODO: Does 'bval' to be own space, or can we do a swap? Will that be faster or slower?
//    unsigned** bid = (unsigned**) calloc((N/B)+1,sizeof(int*));
//    unsigned** bsize = (unsigned**) calloc((N/B)+1,sizeof(int*));
//    unsigned*** bmap = (unsigned***) calloc((N/B)+1,sizeof(int**));

    unsigned* __restrict bcoord = (unsigned*) calloc(N, sizeof(int));
    unsigned short* __restrict bbegin = (unsigned short*) calloc(N, sizeof(short));
    unsigned short* __restrict bprev = (unsigned short*) calloc(N, sizeof(short));

    *bp = (unsigned*) calloc(M, sizeof(int));
    *bval = (float*) malloc(M*sizeof(float));
    *bindices = (unsigned short*) malloc(M*N*sizeof(short));
    *eindices = (unsigned char*) malloc(M*N*sizeof(char));

    bits = ilog2(B);

    /* Process first M */
    for(m = 0; m < N; m++) {
        bcoord[m] = indices[offset2(m,0,M)];    // first nonzero indices
        bprev[m] = bcoord[m] >> bits;
        //sptAppendBlockIndexVector(&hitsr->binds[m], (sptBlockIndex) block_begin_prior[m]);
        (*bindices)[m] = bprev[m];
    }

    //bp[0] = 0;
    //sptAppendNnzIndexVector(&hitsr->bptr, 0);

    //#pragma omp parallel for schedule(runtime)
    for (n = 0; n < M; n++) {
        for (m = 0; m < N; m++) {
            bcoord[m] = indices[offset2(m,n,M)];    // first nonzero indices
            // spt_LocateBeginCoord(block_begin, tsr, block_coord, sb_bits);
            bbegin[m] = bcoord[m] >> bits;
        }

        /* Append einds and values */
        for (m = 0; m < N; m++) {
            i = indices[offset2(m,n,M)];
            e = i < (bbegin[m] << bits) ? i : i - (bbegin[m] << bits);
            (*eindices)[offset2(n,m,N)] = e;
        }

        //sptAppendValueVector(&hitsr->values, tsr->values.data[z]);
        /* z in the same block with last z */
        //byte equal = spt_EqualWithTwoCoordinates(block_begin, block_begin_prior, nmodes);
        e = 1;
        for (m = 0; m < N && e; m++) {
            //if (bbegin[m] != bprev[m]) {
            e = (bbegin[m] == bprev[m]);
            //}
        }

        if (!e) {
            /* ne: #Elements in the last block */
            /* Append block bptr and bidx */
            //sptAppendNnzIndexVector(&hitsr->bptr, (sptBlockIndex)z);
            (*bp)[NB] = n;
            for (m = 0; m < N; m++) {
                // Copy bbegin to bprev
                //sptAppendBlockIndexVector(&hitsr->binds[m], (sptBlockIndex) block_begin[m]);
                (*bindices)[offset2(NB,m,N)] = bbegin[m];
                bprev[m] = bbegin[m];
            }
            NB += 1;
        } // End new block
    }

    //free(bend);
    free(bprev);
    free(bbegin);
    free(bcoord);

  return (NB);
}    // coo_hicoo_insp

#undef min
#undef max
#undef abs
#undef absmin
#undef absmax
#undef floord
#undef sgn
#undef offset2
#undef offset3
#undef offset4
#undef arrinit
#undef arrprnt
#undef B
#undef val
#undef bcol
#undef bmap
#undef bp
#undef brow
#undef bsize
#undef col
#undef p
#undef row
#undef erow
#undef ecol
