.TH "omega" 3 "Sun Jul 12 2020" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
omega
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBAny_Iterator\fP"
.br
.ti -1c
.RI "class \fBBag\fP"
.br
.ti -1c
.RI "class \fBBoolSet\fP"
.br
.RI "\fBBoolSet\fP implemented using bitmasks\&. "
.ti -1c
.RI "class \fBbrainDammage\fP"
.br
.ti -1c
.RI "class \fBCG_chillBuilder\fP"
.br
.ti -1c
.RI "class \fBCG_chillRepr\fP"
.br
.ti -1c
.RI "struct \fBCG_leaf\fP"
.br
.RI "Leaf - a basic code block\&. "
.ti -1c
.RI "struct \fBCG_loop\fP"
.br
.RI "\fBLoop\fP\&. "
.ti -1c
.RI "class \fBCG_outputBuilder\fP"
.br
.ti -1c
.RI "class \fBCG_outputRepr\fP"
.br
.ti -1c
.RI "struct \fBCG_result\fP"
.br
.RI "Tree-like structure holding the iteration space\&. "
.ti -1c
.RI "class \fBCG_roseBuilder\fP"
.br
.ti -1c
.RI "struct \fBCG_split\fP"
.br
.RI "\fBStatement\fP sequence\&. "
.ti -1c
.RI "class \fBCG_stringBuilder\fP"
.br
.ti -1c
.RI "class \fBCG_stringRepr\fP"
.br
.ti -1c
.RI "class \fBCodeGen\fP"
.br
.ti -1c
.RI "struct \fBcodegen_error\fP"
.br
.ti -1c
.RI "class \fBCodeInsertion\fP"
.br
.ti -1c
.RI "class \fBCodeInsertionAttribute\fP"
.br
.ti -1c
.RI "struct \fBCodeInsertionMark\fP"
.br
.ti -1c
.RI "class \fBCodeInsertionVisitor\fP"
.br
.ti -1c
.RI "class \fBCoef_Var_Decl\fP"
.br
.ti -1c
.RI "class \fBCollection\fP"
.br
.ti -1c
.RI "class \fBComp_Constraints\fP"
.br
.ti -1c
.RI "class \fBComp_Problem\fP"
.br
.ti -1c
.RI "class \fBConjunct\fP"
.br
.RI "\fBConjunct\fP\&. "
.ti -1c
.RI "class \fBConst_String\fP"
.br
.ti -1c
.RI "class \fBConstr_Vars_Iter\fP"
.br
.ti -1c
.RI "class \fBConstraint_Handle\fP"
.br
.ti -1c
.RI "class \fBConstraint_Iterator\fP"
.br
.ti -1c
.RI "class \fBConstStringRep\fP"
.br
.ti -1c
.RI "class \fBCS_HashTable\fP"
.br
.ti -1c
.RI "class \fBDNF\fP"
.br
.RI "Disjunctive Normal Form -- list of Conjuncts\&. "
.ti -1c
.RI "class \fBDNF_Iterator\fP"
.br
.ti -1c
.RI "class \fBDynamic_Array\fP"
.br
.ti -1c
.RI "class \fBDynamic_Array1\fP"
.br
.ti -1c
.RI "class \fBDynamic_Array2\fP"
.br
.ti -1c
.RI "class \fBDynamic_Array3\fP"
.br
.ti -1c
.RI "class \fBDynamic_Array4\fP"
.br
.ti -1c
.RI "class \fBEQ_Handle\fP"
.br
.RI "Handle to access EQ constraints\&. "
.ti -1c
.RI "class \fBEQ_Iterator\fP"
.br
.ti -1c
.RI "struct \fBeqn\fP"
.br
.ti -1c
.RI "class \fBF_And\fP"
.br
.RI "Represents the logical conjunction of its children nodes\&. "
.ti -1c
.RI "class \fBF_Declaration\fP"
.br
.RI "Abstract base class that can contain variable declarations\&. "
.ti -1c
.RI "class \fBF_Exists\fP"
.br
.RI "Existential qualifier\&. "
.ti -1c
.RI "class \fBF_Forall\fP"
.br
.RI "Universal qualifier\&. "
.ti -1c
.RI "class \fBF_Not\fP"
.br
.RI "Represents the logical negation of its single child node\&. "
.ti -1c
.RI "class \fBF_Or\fP"
.br
.RI "Represents the logical disjunction of its children nodes\&. "
.ti -1c
.RI "class \fBFormula\fP"
.br
.RI "Presburger \fBFormula\fP base class\&. "
.ti -1c
.RI "class \fBFree_Var_Decl\fP"
.br
.RI "Named global variable\&. "
.ti -1c
.RI "class \fBGenerator\fP"
.br
.ti -1c
.RI "class \fBGEQ_Handle\fP"
.br
.RI "Handle to access GEQ constraints\&. "
.ti -1c
.RI "class \fBGEQ_Iterator\fP"
.br
.ti -1c
.RI "class \fBGlobal_Input_Output_Tuple\fP"
.br
.ti -1c
.RI "class \fBGlobal_Var_Decl\fP"
.br
.RI "Abstract data type for Global Variable declarations\&. "
.ti -1c
.RI "class \fBIterator\fP"
.br
.ti -1c
.RI "class \fBJunkStaticInit\fP"
.br
.ti -1c
.RI "class \fBList\fP"
.br
.ti -1c
.RI "class \fBList_Element\fP"
.br
.ti -1c
.RI "class \fBList_Element_Iterator\fP"
.br
.ti -1c
.RI "class \fBList_Iterator\fP"
.br
.ti -1c
.RI "class \fBMap\fP"
.br
.ti -1c
.RI "class \fBMapElement\fP"
.br
.ti -1c
.RI "class \fBMapElementIterator\fP"
.br
.ti -1c
.RI "class \fBMapping\fP"
.br
.RI "\fBMapping\fP for relations\&. "
.ti -1c
.RI "class \fBMemory\fP"
.br
.ti -1c
.RI "class \fBMMPrefetchInsertion\fP"
.br
.ti -1c
.RI "class \fBOrdered_Bag\fP"
.br
.ti -1c
.RI "struct \fBPolyhedra\fP"
.br
.ti -1c
.RI "class \fBPragmaInsertion\fP"
.br
.ti -1c
.RI "struct \fBpresburger_error\fP"
.br
.ti -1c
.RI "class \fBProblem\fP"
.br
.ti -1c
.RI "class \fBreachable_information\fP"
.br
.RI "Reachability of a graph\&. "
.ti -1c
.RI "class \fBRel_Body\fP"
.br
.RI "\fBRelation\fP body\&. "
.ti -1c
.RI "class \fBRelation\fP"
.br
.RI "\fBRelation\fP representative\&. "
.ti -1c
.RI "class \fBSection\fP"
.br
.ti -1c
.RI "class \fBSection_Iterator\fP"
.br
.ti -1c
.RI "class \fBSequence\fP"
.br
.ti -1c
.RI "class \fBSet\fP"
.br
.ti -1c
.RI "class \fBSimple_List\fP"
.br
.ti -1c
.RI "class \fBSimple_List_Iterator\fP"
.br
.ti -1c
.RI "class \fBSub_Handle\fP"
.br
.ti -1c
.RI "class \fBSub_Iterator\fP"
.br
.ti -1c
.RI "class \fBSubstituteOldVar\fP"
.br
.ti -1c
.RI "class \fBSubstitutions\fP"
.br
.ti -1c
.RI "class \fBTuple\fP"
.br
.ti -1c
.RI "class \fBTuple_Iterator\fP"
.br
.ti -1c
.RI "class \fBVar_Decl\fP"
.br
.ti -1c
.RI "struct \fBVariable_Info\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef long long \fBcoef_t\fP"
.br
.ti -1c
.RI "typedef \fBTuple\fP< int > \fBIntTuple\fP"
.br
.ti -1c
.RI "typedef \fBTuple\fP< \fBRelation\fP > \fBSetTuple\fP"
.br
.ti -1c
.RI "typedef \fBTuple\fP< \fBSetTuple\fP > \fBSetTupleTuple\fP"
.br
.ti -1c
.RI "typedef \fBTuple\fP< \fBRelation\fP > \fBRelTuple\fP"
.br
.ti -1c
.RI "typedef \fBTuple\fP< \fBRelTuple\fP > \fBRelTupleTuple\fP"
.br
.ti -1c
.RI "typedef std::vector< \fBCodeInsertion\fP * > \fBCodeInsertionPtrList\fP"
.br
.ti -1c
.RI "typedef std::vector< \fBCodeInsertion\fP * >::iterator \fBCodeInsertionPtrListItr\fP"
.br
.ti -1c
.RI "typedef int \fBEqnKey\fP"
.br
.ti -1c
.RI "typedef \fBEQ_Handle\fP \fBStride_Handle\fP"
.br
.ti -1c
.RI "typedef \fBVar_Decl\fP * \fBVariable_ID\fP"
.br
.RI "Uniquely identifies variables\&. "
.ti -1c
.RI "typedef \fBGlobal_Var_Decl\fP * \fBGlobal_Var_ID\fP"
.br
.RI "Uniquely identifies global var-s through the whole program\&. "
.ti -1c
.RI "typedef \fBTuple\fP< \fBVariable_ID\fP > \fBVariable_ID_Tuple\fP"
.br
.ti -1c
.RI "typedef \fBSequence\fP< \fBVariable_ID\fP > \fBVariable_ID_Sequence\fP"
.br
.ti -1c
.RI "typedef \fBTuple_Iterator\fP< \fBVariable_ID\fP > \fBVariable_ID_Tuple_Iterator\fP"
.br
.ti -1c
.RI "typedef \fBTuple_Iterator\fP< \fBVariable_ID\fP > \fBVariable_ID_Iterator\fP"
.br
.ti -1c
.RI "typedef \fBVariable_ID_Iterator\fP \fBVariable_Iterator\fP"
.br
.ti -1c
.RI "typedef unsigned char \fBRel_Unknown_Uses\fP"
.br
.ti -1c
.RI "typedef \fBSet\fP< \fBGlobal_Var_ID\fP > \fBg_set\fP"
.br
.ti -1c
.RI "typedef \fBDynamic_Array1\fP< \fBRelation\fP > \fBRel_Array1\fP"
.br
.ti -1c
.RI "typedef \fBDynamic_Array2\fP< \fBRelation\fP > \fBRel_Array2\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBFarkas_Type\fP { \fBBasic_Farkas\fP, \fBDecoupled_Farkas\fP, \fBLinear_Combination_Farkas\fP, \fBPositive_Combination_Farkas\fP, \fBAffine_Combination_Farkas\fP, \fBConvex_Combination_Farkas\fP }"
.br
.ti -1c
.RI "enum \fBnegation_control\fP { \fBany_negation\fP, \fBone_geq_or_eq\fP, \fBone_geq_or_stride\fP }"
.br
.ti -1c
.RI "enum { \fBEQ_BLACK\fP = 0, \fBEQ_RED\fP = 1 }"
.br
.ti -1c
.RI "enum { \fBOC_SOLVE_UNKNOWN\fP = 2, \fBOC_SOLVE_SIMPLIFY\fP = 3 }"
.br
.ti -1c
.RI "enum \fBredType\fP { \fBnotRed\fP =0, \fBredEQ\fP, \fBredGEQ\fP, \fBredLEQ\fP, \fBredStride\fP }"
.br
.ti -1c
.RI "enum \fBredCheck\fP { \fBnoRed\fP =0, \fBredFalse\fP, \fBredConstraints\fP }"
.br
.ti -1c
.RI "enum \fBnormalizeReturnType\fP { \fBnormalize_false\fP, \fBnormalize_uncoupled\fP, \fBnormalize_coupled\fP }"
.br
.ti -1c
.RI "enum \fBNode_Type\fP { \fBOp_Relation\fP, \fBOp_Not\fP, \fBOp_And\fP, \fBOp_Or\fP, \fBOp_Conjunct\fP, \fBOp_Forall\fP, \fBOp_Exists\fP }"
.br
.ti -1c
.RI "enum \fBVar_Kind\fP { \fBInput_Var\fP, \fBSet_Var\fP = Input_Var, \fBOutput_Var\fP, \fBGlobal_Var\fP, \fBForall_Var\fP, \fBExists_Var\fP, \fBWildcard_Var\fP }"
.br
.RI "Variable declaration\&. "
.ti -1c
.RI "enum \fBArgument_Tuple\fP { \fBUnknown_Tuple\fP = 0, \fBInput_Tuple\fP = 1, \fBOutput_Tuple\fP = 2, \fBSet_Tuple\fP = Input_Tuple }"
.br
.ti -1c
.RI "enum \fBCombine_Type\fP { \fBComb_Id\fP, \fBComb_And\fP, \fBComb_Or\fP, \fBComb_AndNot\fP }"
.br
.ti -1c
.RI "enum \fBMerge_Action\fP { \fBMERGE_REGULAR\fP, \fBMERGE_COMPOSE\fP, \fBMERGE_GIST\fP }"
.br
.ti -1c
.RI "enum \fBBound_Type\fP { \fBEXACT_BOUND\fP, \fBUPPER_BOUND\fP, \fBLOWER_BOUND\fP, \fBUNSET_BOUND\fP }"
.br
.RI "Type of conjunct Conjunct can be exact or lower or upper bound\&. "
.ti -1c
.RI "enum \fBGlobal_Kind\fP { \fBFree_Var\fP, \fBCoef_Var\fP, \fBBomega_Var\fP }"
.br
.ti -1c
.RI "enum \fBRel_Body_Status\fP { \fBunder_construction\fP, \fBcompressed\fP, \fBuncompressed\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T > \fBBoolSet\fP< \fBT\fP > \fBoperator|\fP (\fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBa\fP, \fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBb\fP)"
.br
.ti -1c
.RI "template<typename T > \fBBoolSet\fP< \fBT\fP > \fBoperator&\fP (\fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBa\fP, \fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBb\fP)"
.br
.ti -1c
.RI "template<typename T > \fBBoolSet\fP< \fBT\fP > \fBoperator\-\fP (\fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBa\fP, \fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBb\fP)"
.br
.ti -1c
.RI "template<typename T > \fBBoolSet\fP< \fBT\fP > \fBoperator~\fP (\fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBb\fP)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator==\fP (\fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBa\fP, \fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBb\fP)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator!=\fP (\fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBa\fP, \fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBb\fP)"
.br
.ti -1c
.RI "template<typename T > std::ostream & \fBoperator<<\fP (std::ostream &os, \fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBb\fP)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator<\fP (\fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBa\fP, \fBconst\fP \fBBoolSet\fP< \fBT\fP > &\fBb\fP)"
.br
.ti -1c
.RI "template<typename T > \fBconst\fP \fBT\fP & \fBmax\fP (\fBconst\fP \fBT\fP &\fBx\fP, \fBconst\fP \fBT\fP &\fBy\fP)"
.br
.ti -1c
.RI "template<typename T > \fBconst\fP \fBT\fP & \fBmax\fP (\fBconst\fP \fBT\fP &\fBx\fP, \fBconst\fP \fBT\fP &\fBy\fP, \fBconst\fP \fBT\fP &\fBz\fP)"
.br
.ti -1c
.RI "template<typename T > \fBconst\fP \fBT\fP & \fBmin\fP (\fBconst\fP \fBT\fP &\fBx\fP, \fBconst\fP \fBT\fP &\fBy\fP)"
.br
.ti -1c
.RI "template<typename T > \fBconst\fP \fBT\fP & \fBmin\fP (\fBconst\fP \fBT\fP &\fBx\fP, \fBconst\fP \fBT\fP &\fBy\fP, \fBconst\fP \fBT\fP &\fBz\fP)"
.br
.ti -1c
.RI "template<class T > void \fBset_max\fP (\fBT\fP &\fBm\fP, \fBconst\fP \fBT\fP &\fBx\fP)"
.br
.ti -1c
.RI "template<class T > void \fBset_min\fP (\fBT\fP &\fBm\fP, \fBconst\fP \fBT\fP &\fBx\fP)"
.br
.ti -1c
.RI "template<typename T > \fBT\fP \fBcheck_mul\fP (\fBconst\fP \fBT\fP &\fBx\fP, \fBconst\fP \fBT\fP &\fBy\fP)"
.br
.ti -1c
.RI "template<typename T > \fBT\fP \fBabs\fP (\fBconst\fP \fBT\fP &v)"
.br
.ti -1c
.RI "template<class T > \fBT\fP \fBint_div\fP (\fBconst\fP \fBT\fP &\fBa\fP, \fBconst\fP \fBT\fP &\fBb\fP)"
.br
.ti -1c
.RI "template<class T > \fBT\fP \fBint_mod\fP (\fBconst\fP \fBT\fP &\fBa\fP, \fBconst\fP \fBT\fP &\fBb\fP)"
.br
.ti -1c
.RI "template<class T > \fBT\fP \fBint_mod_hat\fP (\fBconst\fP \fBT\fP &\fBa\fP, \fBconst\fP \fBT\fP &\fBb\fP)"
.br
.ti -1c
.RI "template<typename T > \fBT\fP \fBgcd\fP (\fBT\fP \fBb\fP, \fBT\fP \fBa\fP)"
.br
.ti -1c
.RI "template<typename T > \fBT\fP \fBlcm\fP (\fBT\fP \fBb\fP, \fBT\fP \fBa\fP)"
.br
.ti -1c
.RI "template<typename T > \fBT\fP \fBsquare_root\fP (\fBconst\fP \fBT\fP &n, \fBT\fP precision=1)"
.br
.ti -1c
.RI "template<typename T > \fBT\fP \fBfactor\fP (\fBconst\fP \fBT\fP &n)"
.br
.ti -1c
.RI "template<typename T > std::string \fBto_string\fP (\fBconst\fP \fBT\fP &t)"
.br
.ti -1c
.RI "template<typename T > \fBT\fP \fBfrom_string\fP (\fBconst\fP std::string &s)"
.br
.ti -1c
.RI "int \fBoperator==\fP (\fBconst\fP \fBConst_String\fP &\fBx\fP, \fBconst\fP \fBConst_String\fP &\fBy\fP)"
.br
.ti -1c
.RI "int \fBoperator!=\fP (\fBconst\fP \fBConst_String\fP &\fBx\fP, \fBconst\fP \fBConst_String\fP &\fBy\fP)"
.br
.ti -1c
.RI "int \fBoperator<\fP (\fBconst\fP \fBConst_String\fP &\fBx\fP, \fBconst\fP \fBConst_String\fP &\fBy\fP)"
.br
.ti -1c
.RI "int \fBoperator>\fP (\fBconst\fP \fBConst_String\fP &\fBx\fP, \fBconst\fP \fBConst_String\fP &\fBy\fP)"
.br
.ti -1c
.RI "std::vector< SgVarRefExp * > \fBsubstitute\fP (SgNode *tnl, \fBconst\fP SgVariableSymbol *sym, SgExpression *expr, SgNode *root)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutput_inequality_repr\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBGEQ_Handle\fP &inequality, \fBVariable_ID\fP v, \fBconst\fP \fBRelation\fP &\fBR\fP, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > &assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > &unin, \fBstd::set\fP< \fBVariable_ID\fP > excluded_floor_vars=\fBstd::set\fP< \fBVariable_ID\fP >())"
.br
.RI "Output the inequality constraints containing v The return is only one side of the inequality without v\&. "
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutput_substitution_repr\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBEQ_Handle\fP &equality, \fBVariable_ID\fP v, bool apply_v_coef, \fBconst\fP \fBRelation\fP &\fBR\fP, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > &assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > &unin)"
.br
.RI "Create substituting value from equality constraint\&. "
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutput_upper_bound_repr\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBGEQ_Handle\fP &inequality, \fBVariable_ID\fP v, \fBconst\fP \fBRelation\fP &\fBR\fP, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > &assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > &unin)"
.br
.RI "Wrapper to output_inequality_repr When returning NULL, it will replace it with literal 0 in output\&. "
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutput_lower_bound_repr\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBGEQ_Handle\fP &inequality, \fBVariable_ID\fP v, \fBconst\fP \fBEQ_Handle\fP &stride_eq, \fBVariable_ID\fP wc, \fBconst\fP \fBRelation\fP &\fBR\fP, \fBconst\fP \fBRelation\fP &known, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > &assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > &unin)"
.br
.RI "output lower bound with respect to lattice(starting iteration) "
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutput_ident\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &\fBR\fP, \fBVariable_ID\fP v, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > &assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > &unin)"
.br
.RI "output the reference to variable v Return the variable by its name, however if this variable need to be substituted, as in assigned_on_the_fly, return the substitution\&. "
.ti -1c
.RI "std::pair< \fBCG_outputRepr\fP *, std::pair< \fBCG_outputRepr\fP *, int > > \fBoutput_assignment\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &\fBR\fP, int level, \fBconst\fP \fBRelation\fP &known, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > &assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > &unin)"
.br
.RI "output the assignment for loop variable at level It will print if condition when the assignment constains mod constraint\&. such that coefficient is not 1\&. "
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutput_loop\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &\fBR\fP, int level, \fBconst\fP \fBRelation\fP &known, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > &assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > &unin)"
.br
.RI "output the loop control structure at level Finding stride using find_simplest_stride and calculating bound using GEQs\&. Multiple same sided bound will generate min/max operation\&. "
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutput_guard\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &\fBR\fP, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > &assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > &unin)"
.br
.RI "Output the guard condition Output the guard conditions as captured in R\&. "
.ti -1c
.RI "std::vector< \fBCG_outputRepr\fP * > \fBoutput_substitutions\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &\fBR\fP, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > &assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > &unin)"
.br
.RI "Find all substitutions based on current mapping Find substitution for each output variable in R, this can handle integer division\&. "
.ti -1c
.RI "bool \fBbound_must_hit_stride\fP (\fBconst\fP \fBGEQ_Handle\fP &inequality, \fBVariable_ID\fP v, \fBconst\fP \fBEQ_Handle\fP &stride_eq, \fBVariable_ID\fP wc, \fBconst\fP \fBRelation\fP &bounds, \fBconst\fP \fBRelation\fP &known)"
.br
.RI "If the stride equality is guaranteed to hit bound in inequality\&. "
.ti -1c
.RI "std::pair< \fBEQ_Handle\fP, int > \fBfind_simplest_assignment\fP (\fBconst\fP \fBRelation\fP &\fBR\fP, \fBVariable_ID\fP v, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > &assigned_on_the_fly=std::vector< std::pair< \fBCG_outputRepr\fP *, int > >(), bool *has_global_inspector=\fBNULL\fP)"
.br
.RI "Find the simplest(cheapest by cost function) assignment of variable v This handles floor definition wildcards in equality, the second in returned pair is the cost\&. "
.ti -1c
.RI "std::pair< bool, \fBGEQ_Handle\fP > \fBfind_floor_definition\fP (\fBconst\fP \fBRelation\fP &\fBR\fP, \fBVariable_ID\fP v, \fBstd::set\fP< \fBVariable_ID\fP > excluded_floor_vars=\fBstd::set\fP< \fBVariable_ID\fP >())"
.br
.ti -1c
.RI "\fBVariable_ID\fP \fBreplicate_floor_definition\fP (\fBconst\fP \fBRelation\fP &\fBR\fP, \fBconst\fP \fBVariable_ID\fP floor_var, \fBRelation\fP &r, \fBF_Exists\fP *f_exists, \fBF_And\fP *f_root, \fBstd::map\fP< \fBVariable_ID\fP, \fBVariable_ID\fP > &exists_mapping)"
.br
.RI "replicate the floor definition(possibly cascaded to new relation) parameter f_root is inside f_exists, not the other way around\&. return replicated variable in new relation, with all cascaded floor definitions using wildcards defined in the same way as in the original relation\&. "
.ti -1c
.RI "std::pair< \fBEQ_Handle\fP, \fBVariable_ID\fP > \fBfind_simplest_stride\fP (\fBconst\fP \fBRelation\fP &\fBR\fP, \fBVariable_ID\fP v)"
.br
.RI "find the stride involving the specified variable e\&.g\&. v = 2alpha + c The stride equality can have other wildcards as long as they are defined as floor variables\&. "
.ti -1c
.RI "\fBRelation\fP \fBpick_one_guard\fP (\fBconst\fP \fBRelation\fP &\fBR\fP, int level=0)"
.br
.RI "pick one guard condition from relation\&. It can involve multiple constraints when involving wildcards, as long as its complement is a single conjunct\&. "
.ti -1c
.RI "\fBRelation\fP \fBcheckAndRestoreIfProjectedByGlobal\fP (\fBconst\fP \fBRelation\fP &R1, \fBconst\fP \fBRelation\fP &R2, \fBVariable_ID\fP v)"
.br
.RI "Check if a set/input var is projected out of a inequality by a global variable with arity > 0\&. "
.ti -1c
.RI "std::string \fBprint_to_iegen_string\fP (\fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBMMGenerateCode\fP (\fBCG_outputBuilder\fP *ocg, \fBTuple\fP< \fBRelation\fP > &\fBT\fP, \fBTuple\fP< \fBRelation\fP > &old_IS, \fBconst\fP \fBTuple\fP< \fBCG_outputRepr\fP * > &stmt_content, \fBRelation\fP &known, int effort=1)"
.br
.ti -1c
.RI "std::string \fBMMGenerateCode\fP (\fBTuple\fP< \fBRelation\fP > &\fBT\fP, \fBTuple\fP< \fBRelation\fP > &old_IS, \fBRelation\fP &known, int effort=1)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBMMGenerateCode\fP (\fBCG_outputBuilder\fP *ocg, \fBRelTuple\fP &\fBT\fP, \fBSetTuple\fP &old_IS, \fBconst\fP \fBTuple\fP< \fBCG_outputRepr\fP * > &stmt_content, \fBRelation\fP &known, \fBTuple\fP< \fBIntTuple\fP > &smtNonSplitLevels_, std::vector< std::pair< int, std::string > > syncs_, \fBconst\fP \fBTuple\fP< \fBTuple\fP< std::string > > &loopIdxNames_, int effort=1)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutputIdent\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &\fBR\fP, \fBVariable_ID\fP v, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "std::pair< \fBCG_outputRepr\fP *, bool > \fBoutputAssignment\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &R_, \fBVariable_ID\fP v, \fBRelation\fP &enforced, \fBCG_outputRepr\fP *&if_repr, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "std::pair< \fBCG_outputRepr\fP *, bool > \fBoutputBounds\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &bounds, \fBVariable_ID\fP v, int indent, \fBRelation\fP &enforced, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "\fBTuple\fP< \fBCG_outputRepr\fP * > \fBoutputSubstitution\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &\fBR\fP, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutputStatement\fP (\fBCG_outputBuilder\fP *ocg, \fBCG_outputRepr\fP *stmt, int indent, \fBconst\fP \fBRelation\fP &mapping, \fBconst\fP \fBRelation\fP &known, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutputGuard\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &guards_in, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutput_as_guard\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &guards_in, \fBConstraint_Handle\fP \fBe\fP, bool is_equality, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutput_EQ_strides\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &guards_in, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutput_GEQ_strides\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBRelation\fP &guards_in, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutputLBasRepr\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBGEQ_Handle\fP &g, \fBRelation\fP &bounds, \fBVariable_ID\fP v, \fBcoef_t\fP stride, \fBconst\fP \fBEQ_Handle\fP &strideEQ, \fBRelation\fP known, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutputUBasRepr\fP (\fBCG_outputBuilder\fP *ocg, \fBconst\fP \fBGEQ_Handle\fP &g, \fBRelation\fP &bounds, \fBVariable_ID\fP v, \fBcoef_t\fP, \fBconst\fP \fBEQ_Handle\fP &, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly=std::vector< \fBCG_outputRepr\fP * >(\fBlast_level\fP, static_cast< \fBCG_outputRepr\fP * >(\fBNULL\fP)))"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBoutputEasyBoundAsRepr\fP (\fBCG_outputBuilder\fP *ocg, \fBRelation\fP &bounds, \fBconst\fP \fBConstraint_Handle\fP &g, \fBVariable_ID\fP v, bool ignoreWC, int ceiling, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "bool \fBboundHitsStride\fP (\fBconst\fP \fBGEQ_Handle\fP &g, \fBVariable_ID\fP v, \fBconst\fP \fBEQ_Handle\fP &strideEQ, \fBcoef_t\fP, \fBRelation\fP known)"
.br
.ti -1c
.RI "\fBRelation\fP \fBgreatest_common_step\fP (\fBconst\fP \fBTuple\fP< \fBRelation\fP > &I, \fBconst\fP \fBTuple\fP< int > &active, int level, \fBconst\fP \fBRelation\fP &known=\fBRelation::Null\fP())"
.br
.ti -1c
.RI "bool \fBfindFloorInequality\fP (\fBRelation\fP &r, \fBVariable_ID\fP v, \fBGEQ_Handle\fP &h, \fBVariable_ID\fP excluded)"
.br
.ti -1c
.RI "\fBRelation\fP \fBproject_onto_levels\fP (\fBRelation\fP \fBR\fP, int \fBlast_level\fP, bool wildcards)"
.br
.ti -1c
.RI "bool \fBisSimpleStride\fP (\fBconst\fP \fBEQ_Handle\fP &g, \fBVariable_ID\fP v)"
.br
.ti -1c
.RI "int \fBcountStrides\fP (\fBConjunct\fP *\fBc\fP, \fBVariable_ID\fP v, \fBEQ_Handle\fP &strideEQ, bool &simple)"
.br
.ti -1c
.RI "bool \fBhasBound\fP (\fBRelation\fP r, int level, int UB)"
.br
.ti -1c
.RI "bool \fBfind_any_constraint\fP (int s, int level, \fBRelation\fP &kr, int direction, \fBRelation\fP &\fBS\fP, bool approx)"
.br
.ti -1c
.RI "bool \fBhas_nonstride_EQ\fP (\fBRelation\fP r, int level)"
.br
.ti -1c
.RI "\fBRelation\fP \fBpickOverhead\fP (\fBRelation\fP r, int liftTo)"
.br
.ti -1c
.RI "\fBRelation\fP \fBminMaxOverhead\fP (\fBRelation\fP r, int level)"
.br
.ti -1c
.RI "int \fBmax_fs_arity\fP (\fBconst\fP \fBConstraint_Handle\fP &\fBc\fP)"
.br
.ti -1c
.RI "void \fBpostProcessRoseCodeInsertion\fP (SgProject *proj)"
.br
.ti -1c
.RI "void \fBcopyAttributes\fP (SgNode *s, SgNode *d)"
.br
.ti -1c
.RI "\fBCodeInsertionAttribute\fP * \fBgetOrCreateCodeInsertionAttribute\fP (SgNode *node)"
.br
.ti -1c
.RI "\fBchillAST_node\fP * \fBsubstituteChill\fP (\fBconst\fP char *oldvar, \fBCG_chillRepr\fP *newvar, \fBchillAST_node\fP *n, \fBchillAST_node\fP *parent=\fBNULL\fP)"
.br
.ti -1c
.RI "void \fBinit_code_gen\fP ()"
.br
.ti -1c
.RI "void \fBexit_code_gen\fP (void)"
.br
.ti -1c
.RI "bool \fBsubstitute\fP (instruction *in, var_sym *sym, operand expr, base_symtab *st)"
.br
.ti -1c
.RI "bool \fBsubstitute\fP (tree_node *tn, var_sym *sym, operand expr, base_symtab *st)"
.br
.ti -1c
.RI "bool \fBsubstitute\fP (tree_node_list *tnl, var_sym *sym, operand expr, base_symtab *st)"
.br
.ti -1c
.RI "\fBCG_result\fP * \fBgen_recursive\fP (int level, \fBIntTuple\fP &isActive)"
.br
.ti -1c
.RI "\fBSetTuple\fP \fBfilter_function_symbols\fP (\fBSetTuple\fP &sets, bool keep_fs)"
.br
.ti -1c
.RI "\fBRelTuple\fP \fBstrip_function_symbols\fP (\fBSetTuple\fP &sets)"
.br
.ti -1c
.RI "\fBRelTuple\fP \fBextract_function_symbols\fP (\fBSetTuple\fP &sets)"
.br
.ti -1c
.RI "std::string \fBMMGenerateCode\fP (\fBRelTuple\fP &\fBT\fP, \fBSetTuple\fP &old_IS, \fBRelation\fP &known, int effort)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBMMGenerateCode\fP (\fBCG_outputBuilder\fP *ocg, \fBRelTuple\fP &\fBT\fP, \fBSetTuple\fP &old_IS, \fBconst\fP \fBTuple\fP< \fBCG_outputRepr\fP * > &stmt_content, \fBRelation\fP &known, int effort)"
.br
.ti -1c
.RI "std::pair< \fBEQ_Handle\fP, int > \fBfind_simplest_assignment\fP (\fBconst\fP \fBRelation\fP &R_, \fBVariable_ID\fP v, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &assigned_on_the_fly)"
.br
.ti -1c
.RI "\fBRelation\fP \fBVennDiagramForm\fP (\fBTuple\fP< \fBRelation\fP > &Rs, \fBNOT_CONST\fP \fBRelation\fP &Context_In)"
.br
.ti -1c
.RI "\fBRelation\fP \fBVennDiagramForm\fP (\fBNOT_CONST\fP \fBRelation\fP &R_In, \fBNOT_CONST\fP \fBRelation\fP &Context_In=\fBRelation::Null\fP())"
.br
.ti -1c
.RI "\fBRelation\fP \fBConicClosure\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBTransitiveClosure\fP (\fBNOT_CONST\fP \fBRelation\fP &r, int maxExpansion=1, \fBNOT_CONST\fP \fBRelation\fP &IterationSpace=\fBRelation::Null\fP())"
.br
.ti -1c
.RI "\fBRelation\fP \fBcalculateTransitiveClosure\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.ti -1c
.RI "\fBRelation\fP \fBApproxClosure\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.ti -1c
.RI "\fBRelation\fP \fBFarkas\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP, \fBFarkas_Type\fP \fBop\fP, bool early_bailout=false)"
.br
.ti -1c
.RI "\fBRelation\fP \fBSimpleHull\fP (\fBconst\fP \fBRelation\fP &\fBR\fP, bool allow_stride_constraint=false, bool allow_irregular_constraint=false)"
.br
.ti -1c
.RI "\fBRelation\fP \fBSimpleHull\fP (\fBconst\fP std::vector< \fBRelation\fP > &Rs, bool allow_stride_constraint=false, bool allow_irregular_constraint=false)"
.br
.ti -1c
.RI "\fBRelation\fP \fBConvexHull\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.RI "Calculate the Convex Hull of R using the convex combination\&. "
.ti -1c
.RI "\fBRelation\fP \fBDecoupledConvexHull\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.RI "Calculate the DecoupledConvex Hull of R\&. "
.ti -1c
.RI "\fBRelation\fP \fBAffineHull\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.RI "Calculate the Affine Hull using affine combination\&. "
.ti -1c
.RI "\fBRelation\fP \fBLinearHull\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.RI "Calculate the Linear Hull using linear combination\&. "
.ti -1c
.RI "\fBRelation\fP \fBConicHull\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.RI "Calculate the Conic Hull using conic combination\&. "
.ti -1c
.RI "\fBRelation\fP \fBRectHull\fP (\fBNOT_CONST\fP \fBRelation\fP &Rel)"
.br
.RI "Calculate the Rect Hull\&. "
.ti -1c
.RI "\fB__attribute__\fP ((deprecated)) \fBRelation\fP \fBQuickHull\fP(\fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBFastTightHull\fP (\fBNOT_CONST\fP \fBRelation\fP &input_R, \fBNOT_CONST\fP \fBRelation\fP &input_H)"
.br
.ti -1c
.RI "\fBRelation\fP \fBHull\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP, bool stridesAllowed=false, int effort=1, \fBNOT_CONST\fP \fBRelation\fP &knownHull=\fBRelation::Null\fP())"
.br
.ti -1c
.RI "\fBRelation\fP \fBHull\fP (\fBTuple\fP< \fBRelation\fP > &Rs, \fBconst\fP std::vector< bool > &validMask, int effort=1, bool stridesAllowed=false, \fBNOT_CONST\fP \fBRelation\fP &knownHull=\fBRelation::Null\fP())"
.br
.ti -1c
.RI "\fBRelation\fP \fBConvexRepresentation\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.RI "Simplify a union of sets/relations to a minimal (may not be optimal) number of convex regions\&. "
.ti -1c
.RI "void \fBeqnncpy\fP (\fBeqn\fP *dest, \fBeqn\fP *src, int nVars)"
.br
.ti -1c
.RI "void \fBeqnnzero\fP (\fBeqn\fP *\fBe\fP, int nVars)"
.br
.ti -1c
.RI "void \fBcheck_number_EQs\fP (int)"
.br
.ti -1c
.RI "void \fBcheck_number_GEQs\fP (int)"
.br
.ti -1c
.RI "void \fBinitializeOmega\fP (void)"
.br
.ti -1c
.RI "int \fBsingleVarGEQ\fP (\fBeqn\fP *\fBe\fP)"
.br
.ti -1c
.RI "void \fBsetPrintLevel\fP (int level)"
.br
.ti -1c
.RI "void \fBprintHeader\fP ()"
.br
.ti -1c
.RI "void \fBsetOutputFile\fP (FILE *file)"
.br
.ti -1c
.RI "void \fBcheckVars\fP (int nVars)"
.br
.ti -1c
.RI "int \fBcheckIfSingleVar\fP (\fBeqn\fP *\fBe\fP, int \fBi\fP)"
.br
.ti -1c
.RI "void \fBnegateCoefficients\fP (\fBeqn\fP *\fBeqn\fP, int nV)"
.br
.ti -1c
.RI "void \fBcopy_constraint\fP (\fBConstraint_Handle\fP H, \fBconst\fP \fBConstraint_Handle\fP initial)"
.br
.ti -1c
.RI "void \fBcopy_column\fP (\fBProblem\fP *tp, int to_col, \fBProblem\fP *fp, int fr_col, int start_EQ, int start_GEQ)"
.br
.ti -1c
.RI "void \fBzero_column\fP (\fBProblem\fP *tp, int to_col, int start_EQ, int start_GEQ, int no_EQs, int no_GEQs)"
.br
.ti -1c
.RI "\fBConjunct\fP * \fBmerge_conjs\fP (\fBConjunct\fP *conj1, \fBConjunct\fP *conj2, \fBMerge_Action\fP action, \fBRel_Body\fP *body=0)"
.br
.ti -1c
.RI "\fBDNF\fP * \fBconj_and_not_dnf\fP (\fBConjunct\fP *pos_conj, \fBDNF\fP *neg_conjs, bool weak=false)"
.br
.ti -1c
.RI "bool \fBrm_variable\fP (\fBVariable_ID_Tuple\fP &vl, \fBVariable_ID\fP v)"
.br
.ti -1c
.RI "void \fBreset_remap_field\fP (\fBSequence\fP< \fBVariable_ID\fP > &\fBS\fP)"
.br
.ti -1c
.RI "void \fBreset_remap_field\fP (\fBSequence\fP< \fBVariable_ID\fP > &\fBS\fP, int var_no)"
.br
.ti -1c
.RI "void \fBreset_remap_field\fP (\fBVariable_ID\fP v)"
.br
.ti -1c
.RI "void \fBreset_remap_field\fP (\fBVariable_ID_Tuple\fP &\fBS\fP)"
.br
.ti -1c
.RI "void \fBreset_remap_field\fP (\fBVariable_ID_Tuple\fP &\fBS\fP, int var_no)"
.br
.ti -1c
.RI "\fBVariable_ID\fP \fBinput_var\fP (int nth)"
.br
.ti -1c
.RI "\fBVariable_ID\fP \fBoutput_var\fP (int nth)"
.br
.ti -1c
.RI "\fBVariable_ID\fP \fBset_var\fP (int nth)"
.br
.ti -1c
.RI "void \fBcopy_var_decls\fP (\fBVariable_ID_Tuple\fP &new_vl, \fBVariable_ID_Tuple\fP &vl)"
.br
.RI "Copy variable declarations except global var-s due to uniqueness\&. "
.ti -1c
.RI "void \fBfree_var_decls\fP (\fBVariable_ID_Tuple\fP &vl)"
.br
.RI "Destroy variable declarations except global var-s\&. "
.ti -1c
.RI "\fBDynamic_Array1\fP< \fBRelation\fP > * \fBReachable_Nodes\fP (\fBreachable_information\fP *\fBreachable_info\fP)"
.br
.ti -1c
.RI "\fBDynamic_Array1\fP< \fBRelation\fP > * \fBI_Reachable_Nodes\fP (\fBreachable_information\fP *\fBreachable_info\fP)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &o, \fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBcopy\fP (\fBconst\fP \fBRelation\fP &r)"
.br
.ti -1c
.RI "\fBRelation\fP \fBconsume_and_regurgitate\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBUnion\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBr1\fP, \fBNOT_CONST\fP \fBRelation\fP &\fBr2\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBIntersection\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBr1\fP, \fBNOT_CONST\fP \fBRelation\fP &\fBr2\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBExtend_Domain\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.RI "Add 1-more input variable to relation\&. "
.ti -1c
.RI "\fBRelation\fP \fBExtend_Domain\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP, int more)"
.br
.RI "Add more-more input variables to relation\&. "
.ti -1c
.RI "\fBRelation\fP \fBExtend_Range\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.RI "Add 1-more output variable to relation\&. "
.ti -1c
.RI "\fBRelation\fP \fBExtend_Range\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP, int more)"
.br
.RI "Add more-more output variables to relation\&. "
.ti -1c
.RI "\fBRelation\fP \fBExtend_Set\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.RI "Add 1-more variable to set\&. "
.ti -1c
.RI "\fBRelation\fP \fBExtend_Set\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP, int more)"
.br
.RI "Add more-more variables to set\&. "
.ti -1c
.RI "\fBRelation\fP \fBRestrict_Domain\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBr1\fP, \fBNOT_CONST\fP \fBRelation\fP &\fBr2\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBRestrict_Range\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBr1\fP, \fBNOT_CONST\fP \fBRelation\fP &\fBr2\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBDomain\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.ti -1c
.RI "\fBRelation\fP \fBRange\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.ti -1c
.RI "\fBRelation\fP \fBCross_Product\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBA\fP, \fBNOT_CONST\fP \fBRelation\fP &\fBB\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBInverse\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.RI "Inverse the input and output tuple\&. "
.ti -1c
.RI "\fBRelation\fP \fBAfter\fP (\fBNOT_CONST\fP \fBRelation\fP &r, int carried_by, int new_output, int dir=1)"
.br
.ti -1c
.RI "\fBRelation\fP \fBDeltas\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBDeltas\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP, int eq_no)"
.br
.ti -1c
.RI "\fBRelation\fP \fBDeltasToRelation\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP, int n_input, int n_output)"
.br
.ti -1c
.RI "\fBRelation\fP \fBComplement\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.ti -1c
.RI "\fBRelation\fP \fBProject\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP, \fBGlobal_Var_ID\fP v)"
.br
.ti -1c
.RI "\fBRelation\fP \fBProject\fP (\fBNOT_CONST\fP \fBRelation\fP &r, int \fBpos\fP, \fBVar_Kind\fP vkind)"
.br
.ti -1c
.RI "\fBRelation\fP \fBProject\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBS\fP, \fBVariable_ID\fP v)"
.br
.ti -1c
.RI "\fBRelation\fP \fBProject\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBS\fP, \fBSequence\fP< \fBVariable_ID\fP > &s)"
.br
.ti -1c
.RI "\fBRelation\fP \fBProject_Sym\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBProject_On_Sym\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP, \fBNOT_CONST\fP \fBRelation\fP &\fBcontext\fP=\fBRelation::Null\fP())"
.br
.ti -1c
.RI "\fBRelation\fP \fBGistSingleConjunct\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP, \fBNOT_CONST\fP \fBRelation\fP &R2, int effort=0)"
.br
.RI "Compute (gist r1 given r2)\&. Assuming that r2 has only one conjunct\&. r2 may have zero input and output OR may have # in/out vars equal to r1\&. "
.ti -1c
.RI "\fBRelation\fP \fBGist\fP (\fBNOT_CONST\fP \fBRelation\fP &R1, \fBNOT_CONST\fP \fBRelation\fP &R2, int effort=0)"
.br
.ti -1c
.RI "\fBRelation\fP \fBDifference\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBr1\fP, \fBNOT_CONST\fP \fBRelation\fP &\fBr2\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBApproximate\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBR\fP, bool strides_allowed=false)"
.br
.ti -1c
.RI "\fBRelation\fP \fBIdentity\fP (int n_inp)"
.br
.ti -1c
.RI "\fBRelation\fP \fBIdentity\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.ti -1c
.RI "bool \fBMust_Be_Subset\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBr1\fP, \fBNOT_CONST\fP \fBRelation\fP &\fBr2\fP)"
.br
.ti -1c
.RI "bool \fBMight_Be_Subset\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBr1\fP, \fBNOT_CONST\fP \fBRelation\fP &\fBr2\fP)"
.br
.ti -1c
.RI "bool \fBIs_Obvious_Subset\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBr1\fP, \fBNOT_CONST\fP \fBRelation\fP &\fBr2\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBComposition\fP (\fBNOT_CONST\fP \fBRelation\fP &F, \fBNOT_CONST\fP \fBRelation\fP &\fBG\fP)"
.br
.ti -1c
.RI "bool \fBprepare_relations_for_composition\fP (\fBRelation\fP &F, \fBRelation\fP &\fBG\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBJoin\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBG\fP, \fBNOT_CONST\fP \fBRelation\fP &F)"
.br
.RI "Same as Composition\&. "
.ti -1c
.RI "\fBRelation\fP \fBEQs_to_GEQs\fP (\fBNOT_CONST\fP \fBRelation\fP &, bool excludeStrides=false)"
.br
.ti -1c
.RI "\fBRelation\fP \fBSymbolic_Solution\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBS\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBSymbolic_Solution\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBS\fP, \fBSequence\fP< \fBVariable_ID\fP > &\fBT\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBSample_Solution\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBS\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBSolution\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBS\fP, \fBSequence\fP< \fBVariable_ID\fP > &\fBT\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBUpper_Bound\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.RI "Upper bound of the relation in question\&. "
.ti -1c
.RI "\fBRelation\fP \fBLower_Bound\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.RI "Lower bound of the relation in question\&. "
.ti -1c
.RI "\fBRelation\fP \fBmerge_rels\fP (\fBTuple\fP< \fBRelation\fP > &\fBR\fP, \fBconst\fP \fBTuple\fP< \fBstd::map\fP< \fBVariable_ID\fP, std::pair< \fBVar_Kind\fP, int > > > &mapping, \fBconst\fP \fBTuple\fP< bool > &inverse, \fBCombine_Type\fP ctype, int number_input=\-1, int number_output=\-1)"
.br
.ti -1c
.RI "void \fBMapRel1\fP (\fBRelation\fP &inputRel, \fBconst\fP \fBMapping\fP &\fBmap\fP, \fBCombine_Type\fP ctype, int number_input=\-1, int number_output=\-1, bool invalidate_resulting_leading_info=true, bool finalize=true)"
.br
.ti -1c
.RI "\fBRelation\fP \fBMapAndCombineRel2\fP (\fBRelation\fP &R1, \fBRelation\fP &R2, \fBconst\fP \fBMapping\fP &mapping1, \fBconst\fP \fBMapping\fP &mapping2, \fBCombine_Type\fP ctype, int number_input=\-1, int number_output=\-1)"
.br
.ti -1c
.RI "void \fBalign\fP (\fBRel_Body\fP *originalr, \fBRel_Body\fP *newr, \fBF_Exists\fP *fe, \fBFormula\fP *f, \fBconst\fP \fBMapping\fP &mapping, bool &newrIsSet, \fBList\fP< int > &seen_exists, \fBVariable_ID_Tuple\fP &seen_exists_ids)"
.br
.ti -1c
.RI "void \fBInvestigateClosure\fP (\fBRelation\fP r, \fBRelation\fP r_closure, \fBRelation\fP bounds)"
.br
.ti -1c
.RI "void \fBprint_given_bounds\fP (\fBconst\fP \fBRelation\fP &R1, \fBNOT_CONST\fP \fBRelation\fP &input_Bounds)"
.br
.ti -1c
.RI "\fBRelation\fP \fBVennDiagramForm\fP (\fBNOT_CONST\fP \fBRelation\fP &Context_In, \fBTuple\fP< \fBRelation\fP > &Rs, int next, bool anyPositives, int weight)"
.br
.ti -1c
.RI "bool \fBis_lex_forward\fP (\fBRelation\fP \fBR\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBapprox_closure\fP (\fBNOT_CONST\fP \fBRelation\fP &input_r, int n)"
.br
.ti -1c
.RI "\fBRelation\fP \fBget_D_form\fP (\fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBform_region\fP (\fBconst\fP \fBRelation\fP &\fBR\fP, \fBconst\fP \fBRelation\fP &IterationSpace)"
.br
.ti -1c
.RI "\fBRelation\fP \fBform_region1\fP (\fBconst\fP \fBRelation\fP &\fBR\fP, \fBconst\fP \fBRelation\fP &IterationSpace)"
.br
.ti -1c
.RI "bool \fBisD_OK\fP (\fBRelation\fP &\fBR\fP, \fBRelation\fP &\fBD\fP, \fBRelation\fP &AxA)"
.br
.ti -1c
.RI "bool \fBis_in_D_form\fP (\fBRelation\fP &\fBD\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBget_D_closure\fP (\fBRelation\fP &\fBD\fP, int n)"
.br
.ti -1c
.RI "bool \fBcan_get_D_star_form\fP (\fBRelation\fP &\fBD\fP)"
.br
.ti -1c
.RI "bool \fBdoes_intersect_with_identity\fP (\fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "bool \fBdoes_include_identity\fP (\fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "bool \fBBill_closure\fP (\fBRelation\fP &\fBR\fP, \fBRelation\fP &IterationSpace, \fBRelation\fP &R_plus, \fBRelation\fP &R_star)"
.br
.ti -1c
.RI "bool \fBConjunctTransitiveClosure\fP (\fBNOT_CONST\fP \fBRelation\fP &input_R, \fBRelation\fP &IterationSpace, \fBRelation\fP &R_plus, \fBRelation\fP &R_star)"
.br
.ti -1c
.RI "bool \fBTryConjunctTransitiveClosure\fP (\fBNOT_CONST\fP \fBRelation\fP &input_R, \fBRelation\fP &IterationSpace, \fBRelation\fP &R_plus)"
.br
.ti -1c
.RI "bool \fBEqual\fP (\fBconst\fP \fBRelation\fP &\fBr1\fP, \fBconst\fP \fBRelation\fP &\fBr2\fP)"
.br
.ti -1c
.RI "void \fBappendClausesToList\fP (\fBSimple_List\fP< \fBRelation\fP > &L, \fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "void \fBprintRelationList\fP (\fBSimple_List\fP< \fBRelation\fP > &L)"
.br
.ti -1c
.RI "\fBRelation\fP \fBTransitiveClosure0\fP (\fBNOT_CONST\fP \fBRelation\fP &input_r, int maxExpansion, \fBNOT_CONST\fP \fBRelation\fP &input_IterationSpace)"
.br
.ti -1c
.RI "\fBRelation\fP \fBis_DForm_or_Uniform\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.ti -1c
.RI "\fBRelation\fP \fBgetConjunctionNr\fP (\fBNOT_CONST\fP \fBRelation\fP &r, int conjNr)"
.br
.ti -1c
.RI "\fBRelation\fP \fBgetCommonRegion\fP (\fBNOT_CONST\fP \fBRelation\fP &r, \fBconst\fP long *relTab, \fBconst\fP long relCount)"
.br
.ti -1c
.RI "\fBRelation\fP \fBgetRelationsSet\fP (\fBNOT_CONST\fP \fBRelation\fP &r, \fBconst\fP long *relTab, \fBconst\fP long relCount)"
.br
.ti -1c
.RI "\fBRelation\fP \fBrelationsOnCommonRegion\fP (\fBNOT_CONST\fP \fBRelation\fP &r, \fBNOT_CONST\fP \fBRelation\fP &region)"
.br
.ti -1c
.RI "\fBRelation\fP \fBcompose_N\fP (\fBNOT_CONST\fP \fBRelation\fP &input_r)"
.br
.ti -1c
.RI "bool \fBcheckExactness\fP (\fBNOT_CONST\fP \fBRelation\fP &r, \fBNOT_CONST\fP \fBRelation\fP &rplus)"
.br
.ti -1c
.RI "\fBRelation\fP \fBClosureOnUnboundedRegion\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.ti -1c
.RI "\fBRelation\fP \fBSelectRegionForClosure\fP (\fBNOT_CONST\fP \fBRelation\fP &r)"
.br
.ti -1c
.RI "\fBRelation\fP \fBQuickHull\fP (\fBRelation\fP &\fBR\fP)"
.br
.ti -1c
.RI "\fBRelation\fP \fBQuickHull\fP (\fBTuple\fP< \fBRelation\fP > &Rs)"
.br
.ti -1c
.RI "\fBRelation\fP \fBBetterHull\fP (\fBTuple\fP< \fBRelation\fP > &Rs, bool stridesAllowed, bool checkSubsets, \fBNOT_CONST\fP \fBRelation\fP &input_knownHull=\fBRelation::Null\fP())"
.br
.ti -1c
.RI "\fBRelation\fP \fBHull\fP (\fBTuple\fP< \fBRelation\fP > &Rs, \fBTuple\fP< int > &validMask, int effort, bool stridesAllowed, \fBNOT_CONST\fP \fBRelation\fP &knownHull)"
.br
.ti -1c
.RI "\fBRelation\fP \fBCheckForConvexRepresentation\fP (\fBNOT_CONST\fP \fBRelation\fP &R_In)"
.br
.ti -1c
.RI "\fBRelation\fP \fBCheckForConvexPairs\fP (\fBNOT_CONST\fP \fBRelation\fP &\fBS\fP)"
.br
.ti -1c
.RI "void \fBcheck_number_EQs_GEQs\fP (int \fBe\fP, int g)"
.br
.ti -1c
.RI "int \fBnew_WC\fP (\fBConjunct\fP *nc, \fBProblem\fP *)"
.br
.ti -1c
.RI "\fBconst\fP char * \fBget_var_name\fP (unsigned int \fBcol\fP, void *void_conj)"
.br
.ti -1c
.RI "void \fBinternal_copy_conjunct\fP (\fBConjunct\fP *to, \fBConjunct\fP *fr)"
.br
.ti -1c
.RI "void \fBcopy_conj_header\fP (\fBConjunct\fP *to, \fBConjunct\fP *fr)"
.br
.ti -1c
.RI "\fBConjunct\fP * \fB_merge_conjs\fP (\fBConjunct\fP *conj1, \fBConjunct\fP *conj2, \fBMerge_Action\fP action, \fBRel_Body\fP *body)"
.br
.ti -1c
.RI "int \fBsimplify_conj\fP (\fBConjunct\fP *conj, int ver_sim, int simplificationEffort, int color)"
.br
.ti -1c
.RI "\fBDNF\fP * \fBDNF_and_DNF\fP (\fBDNF\fP *dnf1, \fBDNF\fP *dnf2)"
.br
.ti -1c
.RI "\fBDNF\fP * \fBDNF_and_conj\fP (\fBDNF\fP *dnf, \fBConjunct\fP *conj)"
.br
.ti -1c
.RI "\fBDNF\fP * \fBnegate_conj\fP (\fBConjunct\fP *conj)"
.br
.ti -1c
.RI "void \fBprint_var_addrs\fP (std::string &s, \fBVariable_ID\fP v)"
.br
.ti -1c
.RI "\fBGlobal_Input_Output_Tuple\fP \fBinput_vars\fP (\fBInput_Var\fP)"
.br
.ti -1c
.RI "\fBGlobal_Input_Output_Tuple\fP \fBoutput_vars\fP (\fBOutput_Var\fP)"
.br
.ti -1c
.RI "void \fBdump_rels\fP (\fBRel_Array2\fP &\fBa\fP, \fBreachable_information\fP *\fBreachable_info\fP)"
.br
.ti -1c
.RI "void \fBdump_sets\fP (\fBRel_Array1\fP &\fBa\fP, \fBreachable_information\fP *\fBreachable_info\fP)"
.br
.ti -1c
.RI "bool \fBdo_subset_check\fP (\fBNOT_CONST\fP \fBRelation\fP &input_r1, \fBNOT_CONST\fP \fBRelation\fP &input_r2)"
.br
.ti -1c
.RI "void \fBremap_DNF_vars\fP (\fBRel_Body\fP *map_rel, \fBRel_Body\fP *ref_rel)"
.br
.ti -1c
.RI "\fBRelation\fP \fBprojectOntoJust\fP (\fBRelation\fP \fBR\fP, \fBVariable_ID\fP v)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (\fBconst\fP \fBRelation\fP &, \fBconst\fP \fBRelation\fP &)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBcheckLoopLevel\fP = 0"
.br
.ti -1c
.RI "int \fBstmtForLoopCheck\fP"
.br
.ti -1c
.RI "int \fBupperBoundForLevel\fP"
.br
.ti -1c
.RI "int \fBlowerBoundForLevel\fP"
.br
.ti -1c
.RI "\fBconst\fP int \fBCS_HashTable_Size\fP = 1000"
.br
.ti -1c
.RI "char * \fBk_ocg_comment\fP"
.br
.ti -1c
.RI "int \fBlast_level\fP"
.br
.ti -1c
.RI "std::vector< std::vector< int > > \fBsmtNonSplitLevels\fP"
.br
.ti -1c
.RI "std::vector< std::vector< std::string > > \fBloopIdxNames\fP"
.br
.ti -1c
.RI "std::vector< std::pair< int, std::string > > \fBsyncs\fP"
.br
.ti -1c
.RI "bool \fBfillInBounds\fP = false"
.br
.ti -1c
.RI "char * \fBk_s2c_pragma\fP"
.br
.ti -1c
.RI "char * \fBk_cuda_dim3\fP"
.br
.ti -1c
.RI "char * \fBk_cuda_kernel\fP"
.br
.ti -1c
.RI "char * \fBk_cuda_modifier\fP"
.br
.ti -1c
.RI "char * \fBk_cuda_texture_memory\fP"
.br
.ti -1c
.RI "\fBconst\fP char * \fBlibcode_gen_ver_string\fP = ''"
.br
.ti -1c
.RI "\fBconst\fP char * \fBlibcode_gen_who_string\fP = ''"
.br
.ti -1c
.RI "\fBconst\fP char * \fBlibcode_gen_suif_string\fP = ''"
.br
.ti -1c
.RI "\fBSetTuple\fP \fBnew_IS\fP"
.br
.ti -1c
.RI "\fBSetTupleTuple\fP \fBprojected_nIS\fP"
.br
.ti -1c
.RI "\fBTuple\fP< \fBCG_outputRepr\fP * > \fBstatementInfo\fP"
.br
.ti -1c
.RI "\fBRelTuple\fP \fBtransformations\fP"
.br
.ti -1c
.RI "int \fBcode_gen_debug\fP =0"
.br
.ti -1c
.RI "int \fBvar_substitution_threshold\fP = 100"
.br
.ti -1c
.RI "\fBcoef_t\fP \fBfarkasDifficulty\fP"
.br
.ti -1c
.RI "\fBGlobal_Var_ID\fP \fBcoefficient_of_constant_term\fP = &constant_term"
.br
.ti -1c
.RI "int \fBomega_core_debug\fP = 0"
.br
.ti -1c
.RI "int \fBpres_debug\fP =0"
.br
.ti -1c
.RI "int \fBrelation_debug\fP =0"
.br
.ti -1c
.RI "int \fBclosure_presburger_debug\fP = 0"
.br
.ti -1c
.RI "int \fBhull_debug\fP = 0"
.br
.ti -1c
.RI "int \fBfarkas_debug\fP = 0"
.br
.ti -1c
.RI "\fBnegation_control\fP \fBpres_legal_negations\fP = \fBany_negation\fP"
.br
.ti -1c
.RI "int \fBmaxGEQs\fP = 200"
.br
.ti -1c
.RI "int \fBmaxEQs\fP = 100"
.br
.ti -1c
.RI "\fBconst\fP int \fBmaxmaxGEQs\fP = 512"
.br
.ti -1c
.RI "\fBconst\fP int \fBmaxmaxEQs\fP = 256"
.br
.ti -1c
.RI "char \fBwildName\fP [200][20]"
.br
.ti -1c
.RI "FILE * \fBoutputFile\fP = stderr"
.br
.ti -1c
.RI "int \fBmayBeRed\fP = 0"
.br
.ti -1c
.RI "\fBeqn\fP \fBSUBs\fP []"
.br
.ti -1c
.RI "\fBMemory\fP \fBredMemory\fP []"
.br
.ti -1c
.RI "int \fBprint_in_code_gen_style\fP = 0"
.br
.ti -1c
.RI "int \fBfindingImplicitEqualities\fP = 0"
.br
.ti -1c
.RI "int \fBfirstCheckForRedundantEquations\fP = 0"
.br
.ti -1c
.RI "int \fBuse_ugly_names\fP = 0"
.br
.ti -1c
.RI "int \fBdoItAgain\fP"
.br
.ti -1c
.RI "int \fBnewVar\fP = \-1"
.br
.ti -1c
.RI "int \fBconservative\fP = 0"
.br
.ti -1c
.RI "int \fBnextWildcard\fP = 0"
.br
.ti -1c
.RI "int \fBtrace\fP = 1"
.br
.ti -1c
.RI "int \fBdepth\fP = 0"
.br
.ti -1c
.RI "int \fBpacking\fP [\fBmaxVars\fP]"
.br
.ti -1c
.RI "int \fBheaderLevel\fP"
.br
.ti -1c
.RI "int \fBinApproximateMode\fP = 0"
.br
.ti -1c
.RI "int \fBinStridesAllowedMode\fP = 0"
.br
.ti -1c
.RI "int \fBaddingOuterEqualities\fP = 0"
.br
.ti -1c
.RI "int \fBouterColor\fP = 0"
.br
.ti -1c
.RI "\fBconst\fP int \fBkeyMult\fP = 31"
.br
.ti -1c
.RI "\fBconst\fP int \fBhashTableSize\fP =5*\fBmaxmaxGEQs\fP"
.br
.ti -1c
.RI "\fBconst\fP int \fBmaxKeys\fP = 8*\fBmaxmaxGEQs\fP"
.br
.ti -1c
.RI "int \fBhashVersion\fP = 0"
.br
.ti -1c
.RI "\fBeqn\fP \fBhashMaster\fP [\fBhashTableSize\fP]"
.br
.ti -1c
.RI "int \fBfastLookup\fP [\fBmaxKeys\fP *2]"
.br
.ti -1c
.RI "int \fBnextKey\fP"
.br
.ti -1c
.RI "int \fBreduceWithSubs\fP = 1"
.br
.ti -1c
.RI "int \fBpleaseNoEqualitiesInSimplifiedProblems\fP = 0"
.br
.ti -1c
.RI "\fBProblem\fP * \fBoriginalProblem\fP = \fBnoProblem\fP"
.br
.ti -1c
.RI "int \fBomegaInitialized\fP = 0"
.br
.ti -1c
.RI "\fBProblem\fP \fBfull_answer\fP"
.br
.ti -1c
.RI "\fBProblem\fP \fBcontext\fP"
.br
.ti -1c
.RI "\fBProblem\fP \fBredProblem\fP"
.br
.ti -1c
.RI "\fBRel_Body\fP \fBnull_rel\fP"
.br
.ti -1c
.RI "int \fBskip_finalization_check\fP =0"
.br
.ti -1c
.RI "\fBGlobal_Input_Output_Tuple\fP \fBinput_vars\fP"
.br
.ti -1c
.RI "\fBGlobal_Input_Output_Tuple\fP \fBoutput_vars\fP"
.br
.ti -1c
.RI "\fBGlobal_Input_Output_Tuple\fP & \fBset_vars\fP = \fBinput_vars\fP"
.br
.ti -1c
.RI "\fBconst\fP int \fBCantBeNegated\fP = INT_MAX\-10"
.br
.ti -1c
.RI "\fBconst\fP int \fBAvoidNegating\fP = INT_MAX\-11"
.br
.ti -1c
.RI "FILE * \fBDebugFile\fP =stderr"
.br
.ti -1c
.RI "int \fBmega_total\fP"
.br
.ti -1c
.RI "int \fBwildCardInstanceNumber\fP"
.br
.RI "Counter for the wild card instance number, reused in different scope\&. "
.ti -1c
.RI "\fBconst\fP \fBRel_Unknown_Uses\fP \fBno_u\fP = 1"
.br
.ti -1c
.RI "\fBconst\fP \fBRel_Unknown_Uses\fP \fBand_u\fP = 2"
.br
.ti -1c
.RI "\fBconst\fP \fBRel_Unknown_Uses\fP \fBor_u\fP = 4"
.br
.ti -1c
.RI "int \fBNR_CONJUNCTS\fP"
.br
.ti -1c
.RI "int \fBMAX_CONJUNCTS\fP"
.br
.ti -1c
.RI "int \fBs_rdt_constrs\fP"
.br
.ti -1c
.RI "\fBconst\fP int \fBN_greek_letters\fP = 19"
.br
.ti -1c
.RI "char \fBgreek_letters\fP [19][10]"
.br
.ti -1c
.RI "\fBconst\fP int \fBnumBuffers\fP = 50"
.br
.ti -1c
.RI "\fBconst\fP int \fBbufferSize\fP = 90"
.br
.ti -1c
.RI "char \fBnameBuffers\fP [\fBnumBuffers\fP][\fBbufferSize\fP]"
.br
.ti -1c
.RI "int \fBnextBuffer\fP = 0"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef std::vector<\fBCodeInsertion\fP*> \fBomega::CodeInsertionPtrList\fP"

.SS "typedef std::vector<\fBCodeInsertion\fP*>::iterator \fBomega::CodeInsertionPtrListItr\fP"

.SS "typedef long long \fBomega::coef_t\fP"

.SS "typedef int \fBomega::EqnKey\fP"

.SS "typedef \fBSet\fP<\fBGlobal_Var_ID\fP> \fBomega::g_set\fP"

.SS "typedef \fBGlobal_Var_Decl\fP* \fBomega::Global_Var_ID\fP"

.PP
Uniquely identifies global var-s through the whole program\&. 
.SS "typedef \fBTuple\fP<int> \fBomega::IntTuple\fP"

.SS "typedef \fBDynamic_Array1\fP<\fBRelation\fP> \fBomega::Rel_Array1\fP"

.SS "typedef \fBDynamic_Array2\fP<\fBRelation\fP> \fBomega::Rel_Array2\fP"

.SS "typedef unsigned char \fBomega::Rel_Unknown_Uses\fP"

.SS "typedef \fBTuple\fP<\fBRelation\fP> \fBomega::RelTuple\fP"

.SS "typedef \fBTuple\fP<\fBRelTuple\fP> \fBomega::RelTupleTuple\fP"

.SS "typedef \fBTuple\fP<\fBRelation\fP> \fBomega::SetTuple\fP"

.SS "typedef \fBTuple\fP<\fBSetTuple\fP> \fBomega::SetTupleTuple\fP"

.SS "typedef \fBEQ_Handle\fP \fBomega::Stride_Handle\fP"

.SS "typedef \fBVar_Decl\fP* \fBomega::Variable_ID\fP"

.PP
Uniquely identifies variables\&. 
.SS "typedef \fBTuple_Iterator\fP<\fBVariable_ID\fP> \fBomega::Variable_ID_Iterator\fP"

.SS "typedef \fBSequence\fP<\fBVariable_ID\fP> \fBomega::Variable_ID_Sequence\fP"

.SS "typedef \fBTuple\fP<\fBVariable_ID\fP> \fBomega::Variable_ID_Tuple\fP"

.SS "typedef \fBTuple_Iterator\fP<\fBVariable_ID\fP> \fBomega::Variable_ID_Tuple_Iterator\fP"

.SS "typedef \fBVariable_ID_Iterator\fP \fBomega::Variable_Iterator\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIEQ_BLACK \fP\fP
.TP
\fB\fIEQ_RED \fP\fP
.SS "anonymous enum"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIOC_SOLVE_UNKNOWN \fP\fP
.TP
\fB\fIOC_SOLVE_SIMPLIFY \fP\fP
.SS "enum \fBomega::Argument_Tuple\fP"
Only Input, Output, and \fBSet\fP can be passed to get_local, but the values 0 and 3 are also used internally\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIUnknown_Tuple \fP\fP
.TP
\fB\fIInput_Tuple \fP\fP
.TP
\fB\fIOutput_Tuple \fP\fP
.TP
\fB\fISet_Tuple \fP\fP
.SS "enum \fBomega::Bound_Type\fP"

.PP
Type of conjunct \fBConjunct\fP can be exact or lower or upper bound\&. 
.IP "\(bu" 2
For lower bound conjunct, the upper bound is assumed to be true;
.IP "\(bu" 2
For upper bound conjunct, the lower bound is assumed to be false 
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIEXACT_BOUND \fP\fP
.TP
\fB\fIUPPER_BOUND \fP\fP
.TP
\fB\fILOWER_BOUND \fP\fP
.TP
\fB\fIUNSET_BOUND \fP\fP
.SS "enum \fBomega::Combine_Type\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIComb_Id \fP\fP
.TP
\fB\fIComb_And \fP\fP
.TP
\fB\fIComb_Or \fP\fP
.TP
\fB\fIComb_AndNot \fP\fP
.SS "enum \fBomega::Farkas_Type\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIBasic_Farkas \fP\fP
.TP
\fB\fIDecoupled_Farkas \fP\fP
.TP
\fB\fILinear_Combination_Farkas \fP\fP
.TP
\fB\fIPositive_Combination_Farkas \fP\fP
.TP
\fB\fIAffine_Combination_Farkas \fP\fP
.TP
\fB\fIConvex_Combination_Farkas \fP\fP
.SS "enum \fBomega::Global_Kind\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIFree_Var \fP\fP
.TP
\fB\fICoef_Var \fP\fP
.TP
\fB\fIBomega_Var \fP\fP
.SS "enum \fBomega::Merge_Action\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIMERGE_REGULAR \fP\fP
.TP
\fB\fIMERGE_COMPOSE \fP\fP
.TP
\fB\fIMERGE_GIST \fP\fP
.SS "enum \fBomega::negation_control\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIany_negation \fP\fP
.TP
\fB\fIone_geq_or_eq \fP\fP
.TP
\fB\fIone_geq_or_stride \fP\fP
.SS "enum \fBomega::Node_Type\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIOp_Relation \fP\fP
.TP
\fB\fIOp_Not \fP\fP
.TP
\fB\fIOp_And \fP\fP
.TP
\fB\fIOp_Or \fP\fP
.TP
\fB\fIOp_Conjunct \fP\fP
.TP
\fB\fIOp_Forall \fP\fP
.TP
\fB\fIOp_Exists \fP\fP
.SS "enum \fBomega::normalizeReturnType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fInormalize_false \fP\fP
.TP
\fB\fInormalize_uncoupled \fP\fP
.TP
\fB\fInormalize_coupled \fP\fP
.SS "enum \fBomega::redCheck\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fInoRed \fP\fP
.TP
\fB\fIredFalse \fP\fP
.TP
\fB\fIredConstraints \fP\fP
.SS "enum \fBomega::redType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fInotRed \fP\fP
.TP
\fB\fIredEQ \fP\fP
.TP
\fB\fIredGEQ \fP\fP
.TP
\fB\fIredLEQ \fP\fP
.TP
\fB\fIredStride \fP\fP
.SS "enum \fBomega::Rel_Body_Status\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIunder_construction \fP\fP
.TP
\fB\fIcompressed \fP\fP
.TP
\fB\fIuncompressed \fP\fP
.SS "enum \fBomega::Var_Kind\fP"

.PP
Variable declaration\&. 
.IP "\(bu" 2
Variables are free or quantified\&.
.IP "  \(bu" 4
Free variables are classified as input, output and global\&.
.IP "  \(bu" 4
Quantified variables are classified as forall, exists and wildcard\&.
.PP

.IP "\(bu" 2
All global variables are functions symbols of (possibly 0) arguments
.IP "\(bu" 2
Local variables that correspond to >0-ary functions are identified as functions of a prefix of the input, output, or both tuples 
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIInput_Var \fP\fP
.TP
\fB\fISet_Var \fP\fP
.TP
\fB\fIOutput_Var \fP\fP
.TP
\fB\fIGlobal_Var \fP\fP
.TP
\fB\fIForall_Var \fP\fP
.TP
\fB\fIExists_Var \fP\fP
.TP
\fB\fIWildcard_Var \fP\fP
.SH "Function Documentation"
.PP 
.SS "omega::__attribute__ ((deprecated)) &"
A constraint is in the result of QuickHull only if it appears in one of the relations and is directly implied by a single constraint in each of the other relations\&. 
.SS "\fBConjunct\fP* omega::_merge_conjs (\fBConjunct\fP * conj1, \fBConjunct\fP * conj2, \fBMerge_Action\fP action, \fBRel_Body\fP * body)"

.SS "template<typename T > \fBT\fP omega::abs (\fBconst\fP \fBT\fP & v)\fC [inline]\fP"

.SS "\fBRelation\fP omega::AffineHull (\fBNOT_CONST\fP \fBRelation\fP & R)"

.PP
Calculate the Affine Hull using affine combination\&. Tightest set of equality constraints who's intersection contains all of S\&.
.PP
Affine combination is the convex combination without the positivity constraint a_i: \[x \in Affine(S) \iff \exists y_i in S, \exists a_i \in R, \sum_i a_i = 1: x = \sum_i a_iy_i\] This will first call approximate on R to eliminate any wildcards and strides 
.PP
\fBSee also\fP
.RS 4
\fBConvexHull\fP
.RE
.PP
Expensive 
.SS "void omega::appendClausesToList (\fBSimple_List\fP< \fBRelation\fP > & L, \fBRelation\fP & R)"

.SS "\fBRelation\fP omega::approx_closure (\fBNOT_CONST\fP \fBRelation\fP & input_r, int n)"

.SS "\fBRelation\fP omega::ApproxClosure (\fBNOT_CONST\fP \fBRelation\fP & r)"

.SS "\fBRelation\fP omega::BetterHull (\fBTuple\fP< \fBRelation\fP > & Rs, bool stridesAllowed, bool checkSubsets, \fBNOT_CONST\fP \fBRelation\fP & input_knownHull = \fC\fBRelation::Null\fP()\fP)"

.SS "bool omega::Bill_closure (\fBRelation\fP & R, \fBRelation\fP & IterationSpace, \fBRelation\fP & R_plus, \fBRelation\fP & R_star)"

.SS "bool omega::bound_must_hit_stride (\fBconst\fP \fBGEQ_Handle\fP & inequality, \fBVariable_ID\fP v, \fBconst\fP \fBEQ_Handle\fP & stride_eq, \fBVariable_ID\fP wc, \fBconst\fP \fBRelation\fP & bounds, \fBconst\fP \fBRelation\fP & known)"

.PP
If the stride equality is guaranteed to hit bound in inequality\&. 
.SS "bool omega::boundHitsStride (\fBconst\fP \fBGEQ_Handle\fP & g, \fBVariable_ID\fP v, \fBconst\fP \fBEQ_Handle\fP & strideEQ, \fBcoef_t\fP, \fBRelation\fP known)"

.SS "\fBRelation\fP omega::calculateTransitiveClosure (\fBNOT_CONST\fP \fBRelation\fP & r)"

.SS "bool omega::can_get_D_star_form (\fBRelation\fP & D)"

.SS "template<typename T > \fBT\fP omega::check_mul (\fBconst\fP \fBT\fP & x, \fBconst\fP \fBT\fP & y)\fC [inline]\fP"

.SS "void omega::check_number_EQs (int nEQs)"

.SS "void omega::check_number_EQs_GEQs (int e, int g)"

.SS "void omega::check_number_GEQs (int nGEQs)"

.SS "\fBRelation\fP omega::checkAndRestoreIfProjectedByGlobal (\fBconst\fP \fBRelation\fP & R1, \fBconst\fP \fBRelation\fP & R2, \fBVariable_ID\fP v)"

.PP
Check if a set/input var is projected out of a inequality by a global variable with arity > 0\&. 
.SS "bool omega::checkExactness (\fBNOT_CONST\fP \fBRelation\fP & r, \fBNOT_CONST\fP \fBRelation\fP & rplus)"

.SS "\fBRelation\fP omega::CheckForConvexPairs (\fBNOT_CONST\fP \fBRelation\fP & S)"

.SS "\fBRelation\fP omega::CheckForConvexRepresentation (\fBNOT_CONST\fP \fBRelation\fP & R_In)"

.SS "int omega::checkIfSingleVar (\fBeqn\fP * e, int i)"

.SS "void omega::checkVars (int nVars)"

.SS "\fBRelation\fP omega::ClosureOnUnboundedRegion (\fBNOT_CONST\fP \fBRelation\fP & r)"

.SS "\fBRelation\fP omega::compose_N (\fBNOT_CONST\fP \fBRelation\fP & input_r)"

.SS "\fBRelation\fP omega::ConicClosure (\fBNOT_CONST\fP \fBRelation\fP & R)"

.SS "\fBRelation\fP omega::ConicHull (\fBNOT_CONST\fP \fBRelation\fP & R)"

.PP
Calculate the Conic Hull using conic combination\&. Conic hull is the tightest cone that contains \fBS(R)\fP\&.
.PP
Conic combination is the convex combination without the unit constraint on a_i: \[x \in Conic(R) \iff \exists y_i \in R, a_i \geq 0: x = \sum_i a_iy_i\] This will first call approximate on R to eliminate any wildcards and strides 
.PP
\fBSee also\fP
.RS 4
\fBConvexHull\fP
.RE
.PP
Expensive 
.SS "\fBDNF\fP * omega::conj_and_not_dnf (\fBConjunct\fP * pos_conj, \fBDNF\fP * neg_conjs, bool weak = \fCfalse\fP)"

.SS "bool omega::ConjunctTransitiveClosure (\fBNOT_CONST\fP \fBRelation\fP & input_R, \fBRelation\fP & IterationSpace, \fBRelation\fP & R_plus, \fBRelation\fP & R_star)"

.SS "\fBRelation\fP omega::consume_and_regurgitate (\fBNOT_CONST\fP \fBRelation\fP & R)"

.SS "\fBRelation\fP omega::ConvexHull (\fBNOT_CONST\fP \fBRelation\fP & R)"

.PP
Calculate the Convex Hull of R using the convex combination\&. Tightest inequality constraints who's intersection contains all of S\&. \[x \in Convex(S) \iff \exists y_i \in S, a_i \geq 0, \sum_i a_i = 1: x = \sum_i a_iy_i\]
.PP
This will first call approximate on R to eliminate any wildcards and strides\&.
.PP
Expensive 
.SS "\fBRelation\fP omega::ConvexRepresentation (\fBNOT_CONST\fP \fBRelation\fP & R)"

.PP
Simplify a union of sets/relations to a minimal (may not be optimal) number of convex regions\&. If a union of several conjuncts is a convex, their union representaition can be simplified by their convex hull\&. 
.SS "\fBRelation\fP omega::copy (\fBconst\fP \fBRelation\fP & r)"

.SS "void omega::copy_column (\fBProblem\fP * tp, int to_col, \fBProblem\fP * fp, int fr_col, int start_EQ, int start_GEQ)"

.SS "void omega::copy_conj_header (\fBConjunct\fP * to, \fBConjunct\fP * fr)"

.SS "void omega::copy_constraint (\fBConstraint_Handle\fP H, \fBconst\fP \fBConstraint_Handle\fP initial)"

.SS "void omega::copy_var_decls (\fBVariable_ID_Tuple\fP & new_vl, \fBVariable_ID_Tuple\fP & vl)"

.PP
Copy variable declarations except global var-s due to uniqueness\&. 
.SS "void omega::copyAttributes (SgNode * s, SgNode * d)"

.SS "int omega::countStrides (\fBConjunct\fP * c, \fBVariable_ID\fP v, \fBEQ_Handle\fP & strideEQ, bool & simple)"

.SS "\fBRelation\fP omega::DecoupledConvexHull (\fBNOT_CONST\fP \fBRelation\fP & R)"

.PP
Calculate the DecoupledConvex Hull of R\&. DecoupledConvexHull is the same as ConvexHull, except that it only finds constraints that involve both variables x&y if there is a constraint that involves both x&y in one of the conjuncts of R\&. Always contains the convex hull\&.
.PP
This will first call approximate on R to eliminate any wildcards and strides 
.SS "\fBDNF\fP* omega::DNF_and_conj (\fBDNF\fP * dnf, \fBConjunct\fP * conj)"

.SS "\fBDNF\fP* omega::DNF_and_DNF (\fBDNF\fP * dnf1, \fBDNF\fP * dnf2)"

.SS "bool omega::do_subset_check (\fBNOT_CONST\fP \fBRelation\fP & input_r1, \fBNOT_CONST\fP \fBRelation\fP & input_r2)"

.SS "bool omega::does_include_identity (\fBRelation\fP & R)"

.SS "bool omega::does_intersect_with_identity (\fBRelation\fP & R)"

.SS "void omega::dump_rels (\fBRel_Array2\fP & a, \fBreachable_information\fP * reachable_info)"

.SS "void omega::dump_sets (\fBRel_Array1\fP & a, \fBreachable_information\fP * reachable_info)"

.SS "void omega::eqnncpy (\fBeqn\fP * dest, \fBeqn\fP * src, int nVars)\fC [inline]\fP"

.SS "void omega::eqnnzero (\fBeqn\fP * e, int nVars)\fC [inline]\fP"

.SS "bool omega::Equal (\fBconst\fP \fBRelation\fP & r1, \fBconst\fP \fBRelation\fP & r2)"

.SS "void omega::exit_code_gen (void)"

.SS "\fBRelTuple\fP omega::extract_function_symbols (\fBSetTuple\fP & sets)"

.SS "template<typename T > \fBT\fP omega::factor (\fBconst\fP \fBT\fP & n)"

.SS "\fBRelation\fP omega::Farkas (\fBNOT_CONST\fP \fBRelation\fP & R, \fBFarkas_Type\fP op, bool early_bailout = \fCfalse\fP)"

.SS "\fBRelation\fP omega::FastTightHull (\fBNOT_CONST\fP \fBRelation\fP & input_R, \fBNOT_CONST\fP \fBRelation\fP & input_H)"
Will guess the computation complexity to decide whether to use a simpler hull or a more precise one\&. The guess is not always correct and if trying to tackle something that is too complex it will fail by generating a fatal error\&. 
.SS "\fBSetTuple\fP omega::filter_function_symbols (\fBSetTuple\fP & sets, bool keep_fs)"

.SS "bool omega::find_any_constraint (int s, int level, \fBRelation\fP & kr, int direction, \fBRelation\fP & S, bool approx)"

.SS "std::pair< bool, \fBGEQ_Handle\fP > omega::find_floor_definition (\fBconst\fP \fBRelation\fP & R, \fBVariable_ID\fP v, \fBstd::set\fP< \fBVariable_ID\fP > excluded_floor_vars = \fC\fBstd::set\fP<\fBVariable_ID\fP>()\fP)"
@breif find floor definition for wildcard variable v e\&.g\&. m-c <= 4v <= m, (c is constant and 0 <= c < 4)\&. this translates to v = floor(m, 4) and return 4v<=m in this case\&. All wildcards in such inequality are also floor defined\&. 
.SS "std::pair< \fBEQ_Handle\fP, int > omega::find_simplest_assignment (\fBconst\fP \fBRelation\fP & R, \fBVariable_ID\fP v, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > & assigned_on_the_fly = \fCstd::vector<std::pair<\fBCG_outputRepr\fP *, int> >()\fP, bool * has_global_inspector = \fC\fBNULL\fP\fP)"

.PP
Find the simplest(cheapest by cost function) assignment of variable v This handles floor definition wildcards in equality, the second in returned pair is the cost\&. 
.SS "std::pair< \fBEQ_Handle\fP, int > omega::find_simplest_assignment (\fBconst\fP \fBRelation\fP & R_, \fBVariable_ID\fP v, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "std::pair< \fBEQ_Handle\fP, \fBVariable_ID\fP > omega::find_simplest_stride (\fBconst\fP \fBRelation\fP & R, \fBVariable_ID\fP v)"

.PP
find the stride involving the specified variable e\&.g\&. v = 2alpha + c The stride equality can have other wildcards as long as they are defined as floor variables\&. 
.SS "bool omega::findFloorInequality (\fBRelation\fP & r, \fBVariable_ID\fP v, \fBGEQ_Handle\fP & h, \fBVariable_ID\fP excluded)"

.SS "\fBRelation\fP omega::form_region (\fBconst\fP \fBRelation\fP & R, \fBconst\fP \fBRelation\fP & IterationSpace)"

.SS "\fBRelation\fP omega::form_region1 (\fBconst\fP \fBRelation\fP & R, \fBconst\fP \fBRelation\fP & IterationSpace)"

.SS "void omega::free_var_decls (\fBVariable_ID_Tuple\fP & vl)"

.PP
Destroy variable declarations except global var-s\&. 
.SS "template<typename T > \fBT\fP omega::from_string (\fBconst\fP std::string & s)"

.SS "template<typename T > \fBT\fP omega::gcd (\fBT\fP b, \fBT\fP a)\fC [inline]\fP"

.SS "\fBCG_result\fP * omega::gen_recursive (int level, \fBIntTuple\fP & isActive)"

.SS "\fBRelation\fP omega::get_D_closure (\fBRelation\fP & D, int n)"

.SS "\fBRelation\fP omega::get_D_form (\fBRelation\fP & R)"

.SS "\fBconst\fP char* omega::get_var_name (unsigned int col, void * void_conj)"

.SS "\fBRelation\fP omega::getCommonRegion (\fBNOT_CONST\fP \fBRelation\fP & r, \fBconst\fP long * relTab, \fBconst\fP long relCount)"

.SS "\fBRelation\fP omega::getConjunctionNr (\fBNOT_CONST\fP \fBRelation\fP & r, int conjNr)"

.SS "\fBCodeInsertionAttribute\fP* omega::getOrCreateCodeInsertionAttribute (SgNode * node)"

.SS "\fBRelation\fP omega::getRelationsSet (\fBNOT_CONST\fP \fBRelation\fP & r, \fBconst\fP long * relTab, \fBconst\fP long relCount)"

.SS "\fBRelation\fP omega::greatest_common_step (\fBconst\fP \fBTuple\fP< \fBRelation\fP > & I, \fBconst\fP \fBTuple\fP< int > & active, int level, \fBconst\fP \fBRelation\fP & known = \fC\fBRelation::Null\fP()\fP)"

.SS "bool omega::has_nonstride_EQ (\fBRelation\fP r, int level)"

.SS "bool omega::hasBound (\fBRelation\fP r, int level, int UB)"

.SS "\fBRelation\fP omega::Hull (\fBNOT_CONST\fP \fBRelation\fP & R, bool stridesAllowed = \fCfalse\fP, int effort = \fC1\fP, \fBNOT_CONST\fP \fBRelation\fP & knownHull = \fC\fBRelation::Null\fP()\fP)"

.SS "\fBRelation\fP omega::Hull (\fBTuple\fP< \fBRelation\fP > & Rs, \fBconst\fP std::vector< bool > & validMask, int effort = \fC1\fP, bool stridesAllowed = \fCfalse\fP, \fBNOT_CONST\fP \fBRelation\fP & knownHull = \fC\fBRelation::Null\fP()\fP)"

.SS "\fBRelation\fP omega::Hull (\fBTuple\fP< \fBRelation\fP > & Rs, \fBTuple\fP< int > & validMask, int effort, bool stridesAllowed, \fBNOT_CONST\fP \fBRelation\fP & knownHull)"

.SS "\fBRel_Array1\fP * omega::I_Reachable_Nodes (\fBreachable_information\fP * reachable_info)"

.SS "void omega::init_code_gen ()"

.SS "void omega::initializeOmega (void)"

.SS "\fBVariable_ID\fP omega::input_var (int nth)"

.SS "\fBGlobal_Input_Output_Tuple\fP omega::input_vars (\fBInput_Var\fP)"

.SS "template<class T > \fBT\fP omega::int_div (\fBconst\fP \fBT\fP & a, \fBconst\fP \fBT\fP & b)\fC [inline]\fP"

.SS "template<class T > \fBT\fP omega::int_mod (\fBconst\fP \fBT\fP & a, \fBconst\fP \fBT\fP & b)\fC [inline]\fP"

.SS "template<class T > \fBT\fP omega::int_mod_hat (\fBconst\fP \fBT\fP & a, \fBconst\fP \fBT\fP & b)\fC [inline]\fP"

.SS "void omega::internal_copy_conjunct (\fBConjunct\fP * to, \fBConjunct\fP * fr)"

.SS "void omega::InvestigateClosure (\fBRelation\fP r, \fBRelation\fP r_closure, \fBRelation\fP bounds)"

.SS "\fBRelation\fP omega::is_DForm_or_Uniform (\fBNOT_CONST\fP \fBRelation\fP & r)"

.SS "bool omega::is_in_D_form (\fBRelation\fP & D)"

.SS "bool omega::is_lex_forward (\fBRelation\fP R)"

.SS "bool omega::isD_OK (\fBRelation\fP & R, \fBRelation\fP & D, \fBRelation\fP & AxA)"

.SS "bool omega::isSimpleStride (\fBconst\fP \fBEQ_Handle\fP & g, \fBVariable_ID\fP v)"

.SS "template<typename T > \fBT\fP omega::lcm (\fBT\fP b, \fBT\fP a)\fC [inline]\fP"

.SS "\fBRelation\fP omega::LinearHull (\fBNOT_CONST\fP \fBRelation\fP & R)"

.PP
Calculate the Linear Hull using linear combination\&. Linear combination is the convex combination without constraints on a_i: \[x \in Linear(S) \iff \exists y_i \in S, \exists a_i \in R: x = \sum_i a_iy_i\] This will first call approximate on R to eliminate any wildcards and strides 
.PP
\fBSee also\fP
.RS 4
\fBConvexHull\fP
.RE
.PP
Expensive 
.SS "template<typename T > \fBconst\fP \fBT\fP& omega::max (\fBconst\fP \fBT\fP & x, \fBconst\fP \fBT\fP & y)\fC [inline]\fP"

.SS "template<typename T > \fBconst\fP \fBT\fP& omega::max (\fBconst\fP \fBT\fP & x, \fBconst\fP \fBT\fP & y, \fBconst\fP \fBT\fP & z)\fC [inline]\fP"

.SS "int omega::max_fs_arity (\fBconst\fP \fBConstraint_Handle\fP & c)"

.SS "\fBConjunct\fP* omega::merge_conjs (\fBConjunct\fP * conj1, \fBConjunct\fP * conj2, \fBMerge_Action\fP action, \fBRel_Body\fP * body = \fC0\fP)\fC [inline]\fP"

.SS "template<typename T > \fBconst\fP \fBT\fP& omega::min (\fBconst\fP \fBT\fP & x, \fBconst\fP \fBT\fP & y)\fC [inline]\fP"

.SS "template<typename T > \fBconst\fP \fBT\fP& omega::min (\fBconst\fP \fBT\fP & x, \fBconst\fP \fBT\fP & y, \fBconst\fP \fBT\fP & z)\fC [inline]\fP"

.SS "\fBRelation\fP omega::minMaxOverhead (\fBRelation\fP r, int level)"

.SS "\fBCG_outputRepr\fP* omega::MMGenerateCode (\fBCG_outputBuilder\fP * ocg, \fBRelTuple\fP & T, \fBSetTuple\fP & old_IS, \fBconst\fP \fBTuple\fP< \fBCG_outputRepr\fP * > & stmt_content, \fBRelation\fP & known, int effort)"

.SS "\fBCG_outputRepr\fP * omega::MMGenerateCode (\fBCG_outputBuilder\fP * ocg, \fBRelTuple\fP & T, \fBSetTuple\fP & old_IS, \fBconst\fP \fBTuple\fP< \fBCG_outputRepr\fP * > & stmt_content, \fBRelation\fP & known, \fBTuple\fP< \fBIntTuple\fP > & smtNonSplitLevels_, std::vector< std::pair< int, std::string > > syncs_, \fBconst\fP \fBTuple\fP< \fBTuple\fP< std::string > > & loopIdxNames_, int effort = \fC1\fP)"

.SS "\fBCG_outputRepr\fP* omega::MMGenerateCode (\fBCG_outputBuilder\fP * ocg, \fBTuple\fP< \fBRelation\fP > & T, \fBTuple\fP< \fBRelation\fP > & old_IS, \fBconst\fP \fBTuple\fP< \fBCG_outputRepr\fP * > & stmt_content, \fBRelation\fP & known, int effort = \fC1\fP)"

.SS "std::string omega::MMGenerateCode (\fBRelTuple\fP & T, \fBSetTuple\fP & old_IS, \fBRelation\fP & known, int effort)"

.SS "std::string omega::MMGenerateCode (\fBTuple\fP< \fBRelation\fP > & T, \fBTuple\fP< \fBRelation\fP > & old_IS, \fBRelation\fP & known, int effort = \fC1\fP)"

.SS "\fBDNF\fP* omega::negate_conj (\fBConjunct\fP * conj)"

.SS "void omega::negateCoefficients (\fBeqn\fP * eqn, int nV)"

.SS "int omega::new_WC (\fBConjunct\fP * nc, \fBProblem\fP *)"

.SS "template<typename T > bool omega::operator!= (\fBconst\fP \fBBoolSet\fP< \fBT\fP > & a, \fBconst\fP \fBBoolSet\fP< \fBT\fP > & b)"

.SS "int omega::operator!= (\fBconst\fP \fBConst_String\fP & x, \fBconst\fP \fBConst_String\fP & y)"

.SS "template<typename T > \fBBoolSet\fP<\fBT\fP> omega::operator& (\fBconst\fP \fBBoolSet\fP< \fBT\fP > & a, \fBconst\fP \fBBoolSet\fP< \fBT\fP > & b)"

.SS "template<typename T > \fBBoolSet\fP<\fBT\fP> omega::operator\- (\fBconst\fP \fBBoolSet\fP< \fBT\fP > & a, \fBconst\fP \fBBoolSet\fP< \fBT\fP > & b)"

.SS "template<typename T > bool omega::operator< (\fBconst\fP \fBBoolSet\fP< \fBT\fP > & a, \fBconst\fP \fBBoolSet\fP< \fBT\fP > & b)"

.SS "int omega::operator< (\fBconst\fP \fBConst_String\fP & x, \fBconst\fP \fBConst_String\fP & y)"

.SS "std::ostream& omega::operator<< (std::ostream & o, \fBRelation\fP & R)\fC [inline]\fP"

.SS "template<typename T > std::ostream& omega::operator<< (std::ostream & os, \fBconst\fP \fBBoolSet\fP< \fBT\fP > & b)"

.SS "template<typename T > bool omega::operator== (\fBconst\fP \fBBoolSet\fP< \fBT\fP > & a, \fBconst\fP \fBBoolSet\fP< \fBT\fP > & b)"

.SS "int omega::operator== (\fBconst\fP \fBConst_String\fP & x, \fBconst\fP \fBConst_String\fP & y)"

.SS "bool omega::operator== (\fBconst\fP \fBRelation\fP &, \fBconst\fP \fBRelation\fP &)"

.SS "int omega::operator> (\fBconst\fP \fBConst_String\fP & x, \fBconst\fP \fBConst_String\fP & y)"

.SS "template<typename T > \fBBoolSet\fP<\fBT\fP> omega::operator| (\fBconst\fP \fBBoolSet\fP< \fBT\fP > & a, \fBconst\fP \fBBoolSet\fP< \fBT\fP > & b)"

.SS "template<typename T > \fBBoolSet\fP<\fBT\fP> omega::operator~ (\fBconst\fP \fBBoolSet\fP< \fBT\fP > & b)"

.SS "\fBCG_outputRepr\fP * omega::output_as_guard (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & guards_in, \fBConstraint_Handle\fP e, bool is_equality, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "std::pair< \fBCG_outputRepr\fP *, std::pair< \fBCG_outputRepr\fP *, int > > omega::output_assignment (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & R, int level, \fBconst\fP \fBRelation\fP & known, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > & assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > & unin)"

.PP
output the assignment for loop variable at level It will print if condition when the assignment constains mod constraint\&. such that coefficient is not 1\&. 
.SS "\fBCG_outputRepr\fP * omega::output_EQ_strides (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & guards_in, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "\fBCG_outputRepr\fP * omega::output_GEQ_strides (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & guards_in, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "\fBCG_outputRepr\fP * omega::output_guard (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & R, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > & assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > & unin)"

.PP
Output the guard condition Output the guard conditions as captured in R\&. 
.SS "\fBCG_outputRepr\fP * omega::output_ident (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & R, \fBVariable_ID\fP v, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > & assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > & unin)"

.PP
output the reference to variable v Return the variable by its name, however if this variable need to be substituted, as in assigned_on_the_fly, return the substitution\&. 
.SS "\fBCG_outputRepr\fP * omega::output_inequality_repr (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBGEQ_Handle\fP & inequality, \fBVariable_ID\fP v, \fBconst\fP \fBRelation\fP & R, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > & assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > & unin, \fBstd::set\fP< \fBVariable_ID\fP > excluded_floor_vars = \fC\fBstd::set\fP<\fBVariable_ID\fP>()\fP)"

.PP
Output the inequality constraints containing v The return is only one side of the inequality without v\&. 
.SS "\fBCG_outputRepr\fP * omega::output_loop (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & R, int level, \fBconst\fP \fBRelation\fP & known, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > & assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > & unin)"

.PP
output the loop control structure at level Finding stride using find_simplest_stride and calculating bound using GEQs\&. Multiple same sided bound will generate min/max operation\&. 
.SS "\fBCG_outputRepr\fP * omega::output_lower_bound_repr (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBGEQ_Handle\fP & inequality, \fBVariable_ID\fP v, \fBconst\fP \fBEQ_Handle\fP & stride_eq, \fBVariable_ID\fP wc, \fBconst\fP \fBRelation\fP & R, \fBconst\fP \fBRelation\fP & known, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > & assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > & unin)"

.PP
output lower bound with respect to lattice(starting iteration) 
.SS "\fBCG_outputRepr\fP * omega::output_substitution_repr (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBEQ_Handle\fP & equality, \fBVariable_ID\fP v, bool apply_v_coef, \fBconst\fP \fBRelation\fP & R, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > & assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > & unin)"

.PP
Create substituting value from equality constraint\&. 
.PP
\fBParameters\fP
.RS 4
\fIapply_v_coef\fP Whether v's coefficient has any effect 
.RE
.PP

.SS "std::vector< \fBCG_outputRepr\fP * > omega::output_substitutions (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & R, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > & assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > & unin)"

.PP
Find all substitutions based on current mapping Find substitution for each output variable in R, this can handle integer division\&. 
.SS "\fBCG_outputRepr\fP * omega::output_upper_bound_repr (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBGEQ_Handle\fP & inequality, \fBVariable_ID\fP v, \fBconst\fP \fBRelation\fP & R, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > & assigned_on_the_fly, \fBconst\fP \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > & unin)"

.PP
Wrapper to output_inequality_repr When returning NULL, it will replace it with literal 0 in output\&. 
.SS "\fBVariable_ID\fP omega::output_var (int nth)"

.SS "\fBGlobal_Input_Output_Tuple\fP omega::output_vars (\fBOutput_Var\fP)"

.SS "std::pair< \fBCG_outputRepr\fP *, bool > omega::outputAssignment (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & R_, \fBVariable_ID\fP v, \fBRelation\fP & enforced, \fBCG_outputRepr\fP *& if_repr, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "std::pair< \fBCG_outputRepr\fP *, bool > omega::outputBounds (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & bounds, \fBVariable_ID\fP v, int indent, \fBRelation\fP & enforced, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "\fBCG_outputRepr\fP * omega::outputEasyBoundAsRepr (\fBCG_outputBuilder\fP * ocg, \fBRelation\fP & bounds, \fBconst\fP \fBConstraint_Handle\fP & g, \fBVariable_ID\fP v, bool ignoreWC, int ceiling, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "\fBCG_outputRepr\fP * omega::outputGuard (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & guards_in, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "\fBCG_outputRepr\fP * omega::outputIdent (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & R, \fBVariable_ID\fP v, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "\fBCG_outputRepr\fP * omega::outputLBasRepr (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBGEQ_Handle\fP & g, \fBRelation\fP & bounds, \fBVariable_ID\fP v, \fBcoef_t\fP stride, \fBconst\fP \fBEQ_Handle\fP & strideEQ, \fBRelation\fP known, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "\fBCG_outputRepr\fP * omega::outputStatement (\fBCG_outputBuilder\fP * ocg, \fBCG_outputRepr\fP * stmt, int indent, \fBconst\fP \fBRelation\fP & mapping, \fBconst\fP \fBRelation\fP & known, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "\fBTuple\fP< \fBCG_outputRepr\fP * > omega::outputSubstitution (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBRelation\fP & R, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly)"

.SS "\fBCG_outputRepr\fP * omega::outputUBasRepr (\fBCG_outputBuilder\fP * ocg, \fBconst\fP \fBGEQ_Handle\fP & g, \fBRelation\fP & bounds, \fBVariable_ID\fP v, \fBcoef_t\fP, \fBconst\fP \fBEQ_Handle\fP &, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & assigned_on_the_fly = \fCstd::vector<\fBCG_outputRepr\fP *>(\fBlast_level\fP, static_cast<\fBCG_outputRepr\fP *>(\fBNULL\fP))\fP)"

.SS "\fBRelation\fP omega::pick_one_guard (\fBconst\fP \fBRelation\fP & R, int level = \fC0\fP)"

.PP
pick one guard condition from relation\&. It can involve multiple constraints when involving wildcards, as long as its complement is a single conjunct\&. 
.SS "\fBRelation\fP omega::pickOverhead (\fBRelation\fP r, int liftTo)"

.SS "void omega::postProcessRoseCodeInsertion (SgProject * proj)"

.SS "void omega::print_given_bounds (\fBconst\fP \fBRelation\fP & R1, \fBNOT_CONST\fP \fBRelation\fP & input_Bounds)"

.SS "std::string omega::print_to_iegen_string (\fBRelation\fP & R)"

.SS "void omega::print_var_addrs (std::string & s, \fBVariable_ID\fP v)"

.PP
\fBParameters\fP
.RS 4
\fIs\fP The string to put the output 
.br
\fIv\fP The variable to output 
.RE
.PP

.SS "void omega::printHeader ()"

.SS "void omega::printRelationList (\fBSimple_List\fP< \fBRelation\fP > & L)"

.SS "\fBRelation\fP omega::project_onto_levels (\fBRelation\fP R, int last_level, bool wildcards)"

.SS "\fBRelation\fP omega::projectOntoJust (\fBRelation\fP R, \fBVariable_ID\fP v)"

.SS "\fBRelation\fP omega::QuickHull (\fBRelation\fP & R)"

.SS "\fBRelation\fP omega::QuickHull (\fBTuple\fP< \fBRelation\fP > & Rs)"

.SS "\fBRel_Array1\fP * omega::Reachable_Nodes (\fBreachable_information\fP * reachable_info)"

.SS "\fBRelation\fP omega::RectHull (\fBNOT_CONST\fP \fBRelation\fP & Rel)"

.PP
Calculate the Rect Hull\&. RectHull includes readily-available constraints from relation that can be part of hull, plus rectangular bounds calculated from input/output/set variables' range\&.
.PP
This uses gist and value range to calculate a quick rectangular hull\&. It intends to replace all hull calculations (QuickHull, BetterHull, FastTightHull) beyond the method of ConvexHull (dual representations)\&. In the future, it will support \fBmax(\&.\&.\&.)\fP-like upper bound\&. So RectHull complements ConvexHull in two ways: first for relations that ConvexHull gets too complicated, second for relations where different conjuncts have different symbolic upper bounds\&. 
.SS "\fBRelation\fP omega::relationsOnCommonRegion (\fBNOT_CONST\fP \fBRelation\fP & r, \fBNOT_CONST\fP \fBRelation\fP & region)"

.SS "void omega::remap_DNF_vars (\fBRel_Body\fP * map_rel, \fBRel_Body\fP * ref_rel)"

.SS "\fBVariable_ID\fP omega::replicate_floor_definition (\fBconst\fP \fBRelation\fP & R, \fBconst\fP \fBVariable_ID\fP floor_var, \fBRelation\fP & r, \fBF_Exists\fP * f_exists, \fBF_And\fP * f_root, \fBstd::map\fP< \fBVariable_ID\fP, \fBVariable_ID\fP > & exists_mapping)"

.PP
replicate the floor definition(possibly cascaded to new relation) parameter f_root is inside f_exists, not the other way around\&. return replicated variable in new relation, with all cascaded floor definitions using wildcards defined in the same way as in the original relation\&. 
.SS "void omega::reset_remap_field (\fBSequence\fP< \fBVariable_ID\fP > & S)"

.SS "void omega::reset_remap_field (\fBSequence\fP< \fBVariable_ID\fP > & S, int var_no)"

.SS "void omega::reset_remap_field (\fBVariable_ID\fP v)"

.SS "void omega::reset_remap_field (\fBVariable_ID_Tuple\fP & S)"

.SS "void omega::reset_remap_field (\fBVariable_ID_Tuple\fP & S, int var_no)"

.SS "bool omega::rm_variable (\fBVariable_ID_Tuple\fP & vl, \fBVariable_ID\fP v)"

.SS "\fBRelation\fP omega::SelectRegionForClosure (\fBNOT_CONST\fP \fBRelation\fP & r)"

.SS "template<class T > void omega::set_max (\fBT\fP & m, \fBconst\fP \fBT\fP & x)\fC [inline]\fP"

.SS "template<class T > void omega::set_min (\fBT\fP & m, \fBconst\fP \fBT\fP & x)\fC [inline]\fP"

.SS "\fBVariable_ID\fP omega::set_var (int nth)"

.SS "void omega::setOutputFile (FILE * file)"

.SS "void omega::setPrintLevel (int level)"

.SS "\fBRelation\fP omega::SimpleHull (\fBconst\fP \fBRelation\fP & R, bool allow_stride_constraint = \fCfalse\fP, bool allow_irregular_constraint = \fCfalse\fP)"

.SS "\fBRelation\fP omega::SimpleHull (\fBconst\fP std::vector< \fBRelation\fP > & Rs, bool allow_stride_constraint = \fCfalse\fP, bool allow_irregular_constraint = \fCfalse\fP)"

.SS "int omega::simplify_conj (\fBConjunct\fP * conj, int ver_sim, int simplificationEffort, int color)"

.SS "int omega::singleVarGEQ (\fBeqn\fP * e)"

.SS "template<typename T > \fBT\fP omega::square_root (\fBconst\fP \fBT\fP & n, \fBT\fP precision = \fC1\fP)"

.SS "\fBRelTuple\fP omega::strip_function_symbols (\fBSetTuple\fP & sets)"

.SS "bool omega::substitute (instruction * in, var_sym * sym, operand expr, base_symtab * st)"

.SS "std::vector<SgVarRefExp *> omega::substitute (SgNode * tnl, \fBconst\fP SgVariableSymbol * sym, SgExpression * expr, SgNode * root)"

.SS "bool omega::substitute (tree_node * tn, var_sym * sym, operand expr, base_symtab * st)"

.SS "bool omega::substitute (tree_node_list * tnl, var_sym * sym, operand expr, base_symtab * st)"

.SS "\fBchillAST_node\fP* omega::substituteChill (\fBconst\fP char * oldvar, \fBCG_chillRepr\fP * newvar, \fBchillAST_node\fP * n, \fBchillAST_node\fP * parent = \fC\fBNULL\fP\fP)"

.SS "template<typename T > std::string omega::to_string (\fBconst\fP \fBT\fP & t)"

.SS "\fBRelation\fP omega::TransitiveClosure (\fBNOT_CONST\fP \fBRelation\fP & r, int maxExpansion = \fC1\fP, \fBNOT_CONST\fP \fBRelation\fP & IterationSpace = \fC\fBRelation::Null\fP()\fP)"

.SS "\fBRelation\fP omega::TransitiveClosure0 (\fBNOT_CONST\fP \fBRelation\fP & input_r, int maxExpansion, \fBNOT_CONST\fP \fBRelation\fP & input_IterationSpace)"

.SS "bool omega::TryConjunctTransitiveClosure (\fBNOT_CONST\fP \fBRelation\fP & input_R, \fBRelation\fP & IterationSpace, \fBRelation\fP & R_plus)"

.SS "\fBRelation\fP omega::VennDiagramForm (\fBNOT_CONST\fP \fBRelation\fP & Context_In, \fBTuple\fP< \fBRelation\fP > & Rs, int next, bool anyPositives, int weight)"

.SS "\fBRelation\fP omega::VennDiagramForm (\fBNOT_CONST\fP \fBRelation\fP & R_In, \fBNOT_CONST\fP \fBRelation\fP & Context_In = \fC\fBRelation::Null\fP()\fP)"

.SS "\fBRelation\fP omega::VennDiagramForm (\fBTuple\fP< \fBRelation\fP > & Rs, \fBNOT_CONST\fP \fBRelation\fP & Context_In)"

.SS "void omega::zero_column (\fBProblem\fP * tp, int to_col, int start_EQ, int start_GEQ, int no_EQs, int no_GEQs)"

.SH "Variable Documentation"
.PP 
.SS "int omega::addingOuterEqualities = 0"

.SS "\fBconst\fP \fBRel_Unknown_Uses\fP omega::and_u = 2"

.SS "\fBconst\fP int omega::AvoidNegating = INT_MAX\-11"

.SS "\fBconst\fP int omega::bufferSize = 90"

.SS "\fBconst\fP int omega::CantBeNegated = INT_MAX\-10"

.SS "int omega::checkLoopLevel = 0"

.SS "int omega::closure_presburger_debug = 0"

.SS "int omega::code_gen_debug =0"

.SS "\fBGlobal_Var_ID\fP omega::coefficient_of_constant_term = &constant_term"

.SS "int omega::conservative = 0"

.SS "\fBProblem\fP omega::context"

.SS "\fBconst\fP int omega::CS_HashTable_Size = 1000"

.SS "FILE * omega::DebugFile =stderr"

.SS "int omega::depth = 0"

.SS "int omega::doItAgain"

.SS "int omega::farkas_debug = 0"

.SS "\fBcoef_t\fP omega::farkasDifficulty"

.SS "int omega::fastLookup"

.SS "bool omega::fillInBounds = false"

.SS "int omega::findingImplicitEqualities = 0"

.SS "int omega::firstCheckForRedundantEquations = 0"

.SS "\fBProblem\fP omega::full_answer"

.SS "char omega::greek_letters[19][10]"
\fBInitial value:\fP
.PP
.nf
= {
  "alpha" , "beta" , "gamma" , "delta" , "tau" , "sigma" , "chi" ,
  "omega" , "pi" , "ni" , "Alpha" , "Beta" , "Gamma" , "Delta" ,
  "Tau" , "Sigma" , "Chi" , "Omega" , "Pi" 
}
.fi
.SS "\fBeqn\fP omega::hashMaster"

.SS "\fBconst\fP int omega::hashTableSize =5*\fBmaxmaxGEQs\fP"

.SS "int omega::hashVersion = 0"

.SS "int omega::headerLevel"

.SS "int omega::hull_debug = 0"

.SS "int omega::inApproximateMode = 0"

.SS "\fBGlobal_Input_Output_Tuple\fP omega::input_vars"

.SS "int omega::inStridesAllowedMode = 0"

.SS "char* omega::k_cuda_dim3"

.SS "char* omega::k_cuda_kernel"

.SS "char* omega::k_cuda_modifier"

.SS "char* omega::k_cuda_texture_memory"

.SS "char * omega::k_ocg_comment"

.SS "char* omega::k_s2c_pragma"

.SS "\fBconst\fP int omega::keyMult = 31"

.SS "int omega::last_level"

.SS "\fBconst\fP char* omega::libcode_gen_suif_string = ''"

.SS "\fBconst\fP char* omega::libcode_gen_ver_string = ''"

.SS "\fBconst\fP char* omega::libcode_gen_who_string = ''"

.SS "std::vector< std::vector< std::string > > omega::loopIdxNames"

.SS "int omega::lowerBoundForLevel"

.SS "int omega::MAX_CONJUNCTS"

.SS "int omega::maxEQs = 100"

.SS "int omega::maxGEQs = 200"

.SS "\fBconst\fP int omega::maxKeys = 8*\fBmaxmaxGEQs\fP"

.SS "\fBconst\fP int omega::maxmaxEQs = 256"

.SS "\fBconst\fP int omega::maxmaxGEQs = 512"

.SS "int omega::mayBeRed = 0"

.SS "int omega::mega_total"

.SS "\fBconst\fP int omega::N_greek_letters = 19"

.SS "char omega::nameBuffers[\fBnumBuffers\fP][\fBbufferSize\fP]"

.SS "\fBSetTuple\fP omega::new_IS"

.SS "int omega::newVar = \-1"

.SS "int omega::nextBuffer = 0"

.SS "int omega::nextKey"

.SS "int omega::nextWildcard = 0"

.SS "\fBconst\fP \fBRel_Unknown_Uses\fP omega::no_u = 1"

.SS "int omega::NR_CONJUNCTS"

.SS "\fBRel_Body\fP omega::null_rel"

.SS "\fBconst\fP int omega::numBuffers = 50"

.SS "int omega::omega_core_debug = 0"

.SS "int omega::omegaInitialized = 0"

.SS "\fBconst\fP \fBRel_Unknown_Uses\fP omega::or_u = 4"

.SS "\fBProblem\fP * omega::originalProblem = \fBnoProblem\fP"

.SS "int omega::outerColor = 0"

.SS "\fBGlobal_Input_Output_Tuple\fP omega::output_vars"

.SS "FILE * omega::outputFile = stderr"

.SS "int omega::packing"

.SS "int omega::pleaseNoEqualitiesInSimplifiedProblems = 0"

.SS "int omega::pres_debug =0"

.SS "\fBnegation_control\fP omega::pres_legal_negations = \fBany_negation\fP"

.SS "int omega::print_in_code_gen_style = 0"

.SS "\fBTuple\fP< \fBTuple\fP< \fBRelation\fP > > omega::projected_nIS"

.SS "\fBMemory\fP omega::redMemory"

.SS "\fBProblem\fP omega::redProblem"

.SS "int omega::reduceWithSubs = 1"

.SS "int omega::relation_debug =0"

.SS "int omega::s_rdt_constrs"

.SS "\fBGlobal_Input_Output_Tuple\fP & omega::set_vars = \fBinput_vars\fP"

.SS "int omega::skip_finalization_check =0"

.SS "std::vector< std::vector< int > > omega::smtNonSplitLevels"

.SS "\fBTuple\fP<\fBCG_outputRepr\fP *> omega::statementInfo"

.SS "int omega::stmtForLoopCheck"

.SS "\fBeqn\fP omega::SUBs"

.SS "std::vector< std::pair< int, std::string > > omega::syncs"

.SS "int omega::trace = 1"

.SS "\fBRelTuple\fP omega::transformations"

.SS "int omega::upperBoundForLevel"

.SS "int omega::use_ugly_names = 0"

.SS "int omega::var_substitution_threshold = 100"

.SS "int omega::wildCardInstanceNumber"

.PP
Counter for the wild card instance number, reused in different scope\&. 
.SS "char omega::wildName"

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
