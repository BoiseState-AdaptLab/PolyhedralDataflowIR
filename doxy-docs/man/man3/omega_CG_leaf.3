.TH "omega::CG_leaf" 3 "Sun Jul 12 2020" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
omega::CG_leaf \- Leaf - a basic code block\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <CG\&.h>\fP
.PP
Inherits \fBomega::CG_result\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCG_leaf\fP (\fBCodeGen\fP *\fBcodegen\fP, \fBconst\fP \fBBoolSet\fP<> &active)"
.br
.ti -1c
.RI "\fB~CG_leaf\fP ()"
.br
.ti -1c
.RI "\fBCG_result\fP * \fBrecompute\fP (\fBconst\fP \fBBoolSet\fP<> &parent_active, \fBconst\fP \fBRelation\fP &known, \fBconst\fP \fBRelation\fP &restriction)"
.br
.RI "break down the complete iteration space condition to levels of bound/guard condtions "
.ti -1c
.RI "int \fBpopulateDepth\fP ()"
.br
.RI "calculate each loop's nesting depth Used in liftOverhead - depth start with 0 at leaf "
.ti -1c
.RI "std::pair< \fBCG_result\fP *, \fBRelation\fP > \fBliftOverhead\fP (int \fBdepth\fP, bool propagate_up)"
.br
.RI "redistribute guard condition locations by additional splittings "
.ti -1c
.RI "\fBRelation\fP \fBhoistGuard\fP ()"
.br
.RI "Hoist guard conditions for non-loop levels Enables proper if-condition simplication when outputting actual code\&. "
.ti -1c
.RI "void \fBremoveGuard\fP (\fBconst\fP \fBRelation\fP &guard)"
.br
.ti -1c
.RI "\fBCG_outputRepr\fP * \fBprintRepr\fP (int indent, \fBCG_outputBuilder\fP *ocg, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > &stmts, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > &assigned_on_the_fly, std::vector< \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > > unin, bool \fBprintString\fP=false) \fBconst\fP"
.br
.RI "Signature for printRepr of actual node types\&. "
.ti -1c
.RI "\fBCG_result\fP * \fBclone\fP () \fBconst\fP"
.br
.RI "A deep clone of the tree\&. "
.ti -1c
.RI "void \fBdump\fP (int indent) \fBconst\fP"
.br
.RI "Dump content for debug information\&. "
.ti -1c
.RI "void \fBaddPragma\fP (int stmt, int loop_level, std::string \fBname\fP)"
.br
.RI "Add pragma info prior to code generation\&. "
.ti -1c
.RI "void \fBaddOmpPragma\fP (int stnt, int loop_level, \fBconst\fP std::vector< std::string > &, \fBconst\fP std::vector< std::string > &)"
.br
.RI "Add omp pragma info prior to code generation\&. "
.ti -1c
.RI "virtual void \fBcollectIterationVariableNames\fP (\fBstd::set\fP< std::string > &) noexcept"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBRelation\fP \fBknown_\fP"
.br
.RI "Global known/parents\&. "
.ti -1c
.RI "\fBstd::map\fP< int, \fBRelation\fP > \fBguards_\fP"
.br
.RI "Guard relations for each active statements\&. "
.in -1c
.SH "Detailed Description"
.PP 
Leaf - a basic code block\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "omega::CG_leaf::CG_leaf (\fBCodeGen\fP * codegen, \fBconst\fP \fBBoolSet\fP<> & active)\fC [inline]\fP"

.SS "omega::CG_leaf::~CG_leaf ()\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void omega::CG_leaf::addOmpPragma (int stmt, int loop_level, \fBconst\fP std::vector< std::string > &, \fBconst\fP std::vector< std::string > &)\fC [virtual]\fP"

.PP
Add omp pragma info prior to code generation\&. 
.PP
Implements \fBomega::CG_result\fP\&.
.SS "void omega::CG_leaf::addPragma (int stmt, int loop_level, std::string name)\fC [virtual]\fP"

.PP
Add pragma info prior to code generation\&. 
.PP
Implements \fBomega::CG_result\fP\&.
.SS "\fBCG_result\fP * omega::CG_leaf::clone () const\fC [virtual]\fP"

.PP
A deep clone of the tree\&. 
.PP
Implements \fBomega::CG_result\fP\&.
.SS "void omega::CG_leaf::collectIterationVariableNames (\fBstd::set\fP< std::string > &)\fC [virtual]\fP, \fC [noexcept]\fP"

.PP
Implements \fBomega::CG_result\fP\&.
.SS "void omega::CG_leaf::dump (int indent) const\fC [virtual]\fP"

.PP
Dump content for debug information\&. 
.PP
Reimplemented from \fBomega::CG_result\fP\&.
.SS "\fBRelation\fP omega::CG_leaf::hoistGuard ()\fC [virtual]\fP"

.PP
Hoist guard conditions for non-loop levels Enables proper if-condition simplication when outputting actual code\&. 
.PP
Implements \fBomega::CG_result\fP\&.
.SS "std::pair< \fBCG_result\fP *, \fBRelation\fP > omega::CG_leaf::liftOverhead (int depth, bool propagate_up)\fC [virtual]\fP"

.PP
redistribute guard condition locations by additional splittings 
.PP
Implements \fBomega::CG_result\fP\&.
.SS "int omega::CG_leaf::populateDepth ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
calculate each loop's nesting depth Used in liftOverhead - depth start with 0 at leaf 
.PP
Implements \fBomega::CG_result\fP\&.
.SS "\fBCG_outputRepr\fP * omega::CG_leaf::printRepr (int indent, \fBCG_outputBuilder\fP * ocg, \fBconst\fP std::vector< \fBCG_outputRepr\fP * > & stmts, \fBconst\fP std::vector< std::pair< \fBCG_outputRepr\fP *, int > > & assigned_on_the_fly, std::vector< \fBstd::map\fP< std::string, std::vector< \fBCG_outputRepr\fP * > > > unin, bool printString = \fCfalse\fP) const\fC [virtual]\fP"

.PP
Signature for printRepr of actual node types\&. 
.PP
Implements \fBomega::CG_result\fP\&.
.SS "\fBCG_result\fP * omega::CG_leaf::recompute (\fBconst\fP \fBBoolSet\fP<> & parent_active, \fBconst\fP \fBRelation\fP & known, \fBconst\fP \fBRelation\fP & restriction)\fC [virtual]\fP"

.PP
break down the complete iteration space condition to levels of bound/guard condtions 
.PP
Implements \fBomega::CG_result\fP\&.
.SS "void omega::CG_leaf::removeGuard (\fBconst\fP \fBRelation\fP & guard)\fC [virtual]\fP"

.PP
Implements \fBomega::CG_result\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBstd::map\fP<int, \fBRelation\fP> omega::CG_leaf::guards_"

.PP
Guard relations for each active statements\&. 
.SS "\fBRelation\fP omega::CG_leaf::known_"

.PP
Global known/parents\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
