.TH "iegenlib::Relation" 3 "Sun Jul 12 2020" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
iegenlib::Relation \- A \fBSparseConstraints\fP class that represents a \fBRelation\fP\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <set_relation\&.h>\fP
.PP
Inherits \fBiegenlib::SparseConstraints\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBRelation\fP (std::string \fBstr\fP)"
.br
.ti -1c
.RI "\fBRelation\fP (int \fBinArity\fP, int \fBoutArity\fP)"
.br
.ti -1c
.RI "\fBRelation\fP (\fBconst\fP \fBRelation\fP &other)"
.br
.ti -1c
.RI "\fBRelation\fP & \fBoperator=\fP (\fBconst\fP \fBRelation\fP &other)"
.br
.ti -1c
.RI "\fBRelation\fP & \fBoperator=\fP (\fBconst\fP \fBSet\fP &other)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (\fBconst\fP \fBRelation\fP &other) \fBconst\fP"
.br
.RI "Equals operator\&. "
.ti -1c
.RI "bool \fBoperator<\fP (\fBconst\fP \fBRelation\fP &other) \fBconst\fP"
.br
.RI "Less than operator\&. "
.ti -1c
.RI "\fB~Relation\fP ()"
.br
.ti -1c
.RI "std::string \fBtoString\fP () \fBconst\fP"
.br
.RI "Convert to a human-readable string\&. "
.ti -1c
.RI "std::string \fBprettyPrintString\fP () \fBconst\fP"
.br
.RI "Convert to a human-readable string (substitute in tuple vars)\&. "
.ti -1c
.RI "int \fBinArity\fP () \fBconst\fP"
.br
.RI "Get/Set our in/out arity\&. "
.ti -1c
.RI "int \fBoutArity\fP () \fBconst\fP"
.br
.ti -1c
.RI "void \fBSetinArity\fP (int in)"
.br
.ti -1c
.RI "void \fBSetoutArity\fP (int out)"
.br
.ti -1c
.RI "void \fBsetTupleDecl\fP (\fBTupleDecl\fP tuple_decl)"
.br
.ti -1c
.RI "int \fBarity\fP () \fBconst\fP"
.br
.RI "Get our total arity (in plus out)\&. "
.ti -1c
.RI "std::string \fBtoDotString\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBRelation\fP * \fBCompose\fP (\fBconst\fP \fBRelation\fP *\fBrhs\fP) \fBconst\fP"
.br
.ti -1c
.RI "\fBSet\fP * \fBApply\fP (\fBconst\fP \fBSet\fP *\fBrhs\fP) \fBconst\fP"
.br
.ti -1c
.RI "\fBRelation\fP * \fBUnion\fP (\fBconst\fP \fBRelation\fP *\fBrhs\fP) \fBconst\fP"
.br
.ti -1c
.RI "\fBRelation\fP * \fBIntersect\fP (\fBconst\fP \fBRelation\fP *\fBrhs\fP) \fBconst\fP"
.br
.ti -1c
.RI "\fBRelation\fP * \fBInverse\fP () \fBconst\fP"
.br
.ti -1c
.RI "bool \fBisFunction\fP () \fBconst\fP"
.br
.ti -1c
.RI "bool \fBisFunctionInverse\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBExp\fP * \fBfindFunction\fP (int tupleLocToFind, int startTupleRange, int endTupleRange)"
.br
.ti -1c
.RI "void \fBaddConjunction\fP (\fBConjunction\fP *adoptedConjunction)"
.br
.ti -1c
.RI "\fBRelation\fP * \fBaddUFConstraints\fP (std::string uf1str, std::string opstr, std::string uf2str) \fBconst\fP"
.br
.ti -1c
.RI "\fBRelation\fP * \fBboundDomainRange\fP ()"
.br
.ti -1c
.RI "\fBRelation\fP * \fBaddConstraintsDueToMonotonicity\fP () \fBconst\fP"
.br
.ti -1c
.RI "void \fBnormalize\fP ()"
.br
.RI "Send through ISL to achieve a canonical form\&. "
.ti -1c
.RI "void \fBacceptVisitor\fP (\fBVisitor\fP *v)"
.br
.RI "\fBVisitor\fP design pattern, see \fBVisitor\&.h\fP for usage\&. "
.ti -1c
.RI "\fBRelation\fP * \fBsuperAffineRelation\fP (\fBUFCallMap\fP *ufcmap, bool boundUFCs=true)"
.br
.RI "Same as \fBSet\fP\&. "
.ti -1c
.RI "\fBRelation\fP * \fBsuperAffineRelation\fP ()"
.br
.ti -1c
.RI "\fBRelation\fP * \fBreverseAffineSubstitution\fP (\fBUFCallMap\fP *ufcmap)"
.br
.RI "Same as \fBSet\fP\&. "
.ti -1c
.RI "\fBRelation\fP * \fBprojectOut\fP (int tvar)"
.br
.ti -1c
.RI "\fBRelation\fP * \fBsimplifyForPartialParallel\fP (\fBstd::set\fP< int > parallelTvs)"
.br
.ti -1c
.RI "bool \fBisDefault\fP ()"
.br
.ti -1c
.RI "\fBRelation\fP * \fBdetectUnsatOrFindEqualities\fP (bool *useRule=\fBNULL\fP)"
.br
.ti -1c
.RI "string \fBgetString\fP ()"
.br
.RI "Same as \fBSet\fP\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
A \fBSparseConstraints\fP class that represents a \fBRelation\fP\&. 

This class has two arities related to it to indicate the in arity and the out arity\&.
.PP
Representation example: {[x]->[y]:x < 100 and y > 0} 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "iegenlib::Relation::Relation (std::string str)"

.SS "iegenlib::Relation::Relation (int inArity, int outArity)"

.SS "iegenlib::Relation::Relation (\fBconst\fP \fBRelation\fP & other)"

.SS "iegenlib::Relation::~Relation ()"

.SH "Member Function Documentation"
.PP 
.SS "void iegenlib::Relation::acceptVisitor (\fBVisitor\fP * v)"

.PP
\fBVisitor\fP design pattern, see \fBVisitor\&.h\fP for usage\&. 
.SS "void iegenlib::Relation::addConjunction (\fBConjunction\fP * adoptedConjunction)\fC [virtual]\fP"
addConjunction that checks the \fBConjunction\fP and \fBRelation\fP arities match 
.PP
\fBParameters\fP
.RS 4
\fIadoptedconjuction\fP (adopted) 
.RE
.PP

.PP
Reimplemented from \fBiegenlib::SparseConstraints\fP\&.
.SS "\fBRelation\fP* iegenlib::Relation::addConstraintsDueToMonotonicity () const"
For UFs declared as having a Monotonicity value (see MonotonicType in UninterFunc\&.h) constraints will be added to parameter expressions as needed\&. For example, if we find that f(e1)<f(e2) and f is monotonically non-decreasing, then we will add the constraint that e1<e2\&.
.PP
\fBReturns\fP
.RS 4
\fBRelation\fP will contain new constraints and is owned by caller 
.RE
.PP

.SS "\fBRelation\fP* iegenlib::Relation::addUFConstraints (std::string uf1str, std::string opstr, std::string uf2str) const"
Will create constraints uf1str(e) opstr uf2str(e) for all actual parameters that occur for those UFs\&. See SparseConstraints::addUFConstraintsHelper for more docs\&.
.PP
\fBParameters\fP
.RS 4
\fIuf1str\fP name of first uninterpreted function 
.br
\fIopstr\fP operator that describes relationship between UFs 
.br
\fIuf2str\fP name of second uninterpreted function\&.
.RE
.PP
\fBReturns\fP
.RS 4
\fBRelation\fP will contain new constraints and is owned by caller 
.RE
.PP

.SS "\fBSet\fP * iegenlib::Relation::Apply (\fBconst\fP \fBSet\fP * rhs) const"
Apply this relation to the given set\&. Returns a new \fBSet\fP, which the caller is responsible for deallocating\&. 
.SS "int iegenlib::Relation::arity () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Get our total arity (in plus out)\&. 
.PP
Reimplemented from \fBiegenlib::SparseConstraints\fP\&.
.SS "\fBRelation\fP * iegenlib::Relation::boundDomainRange ()"
Adds constraints due to domain and range of all UFCalls in the \fBRelation\fP\&. Function returns the new \fBRelation\fP with added constraints, leaving caller unchanged\&. User owns the returned \fBRelation\fP object\&. 
.SS "\fBRelation\fP * iegenlib::Relation::Compose (\fBconst\fP \fBRelation\fP * rhs) const"
Compose this relation with the given other one (i\&.e\&., this Compose rhs)\&. Returns a new \fBRelation\fP, which the caller is responsible for deallocating\&. 
.PP
\fBParameters\fP
.RS 4
\fIrhs\fP (not adopted)
.RE
.PP
Compose this relation with the given other one (i\&.e\&., this Compose rhs)\&. Returns a new \fBRelation\fP, which the caller is responsible for deallocating\&. 
.SS "\fBRelation\fP * iegenlib::Relation::detectUnsatOrFindEqualities (bool * useRule = \fC\fBNULL\fP\fP)"

.SS "\fBExp\fP * iegenlib::Relation::findFunction (int tupleLocToFind, int startTupleRange, int endTupleRange)"
Return the expression that describes the value of the tupleLoc specified as a function of the tuple locations in the start through the stop locations\&. 
.SS "string iegenlib::Relation::getString ()"

.PP
Same as \fBSet\fP\&. 
.SS "int iegenlib::Relation::inArity () const\fC [inline]\fP"

.PP
Get/Set our in/out arity\&. 
.SS "\fBRelation\fP * iegenlib::Relation::Intersect (\fBconst\fP \fBRelation\fP * rhs) const"
Intersect this relation with the given other one (i\&.e\&., the Intersect rhs)\&. Returns a new \fBRelation\fP, which the caller is responsible for deallocating\&. 
.PP
\fBParameters\fP
.RS 4
\fIrhs\fP (not adopted)
.RE
.PP
Intersect this relation with the given other one (i\&.e\&., this Intersect rhs)\&. Returns a new \fBRelation\fP, which the caller is responsible for deallocating\&. 
.PP
\fBParameters\fP
.RS 4
\fIrhs\fP (not adopted) 
.RE
.PP

.SS "\fBRelation\fP * iegenlib::Relation::Inverse () const"
Create the inverse of this relation\&. Returns a new \fBRelation\fP, which the caller is responsible for deallocating\&.
.PP
Inverse this relation\&. Returns a new \fBRelation\fP, which the caller is responsible for deallocating\&. 
.SS "bool iegenlib::Relation::isDefault ()\fC [inline]\fP"

.SS "bool iegenlib::Relation::isFunction () const"
Determine whether all of the outputs can be determined as functions of the inputs and/or vice versa\&.
.PP
Determine whether all of the outputs can be determined as functions of the inputs\&. Need to check for each conjunction\&. 
.SS "bool iegenlib::Relation::isFunctionInverse () const"
Determine whether all of the inputs can be determined as functions of the outputs\&. Need to check for each conjunction\&. 
.SS "void iegenlib::Relation::normalize ()"

.PP
Send through ISL to achieve a canonical form\&. 
.SS "bool iegenlib::Relation::operator< (\fBconst\fP \fBRelation\fP & other) const"

.PP
Less than operator\&. Less than operator\&. Compare two \fBRelation\fP in the following order:
.IP "1." 4
by in arity: mInArity
.IP "2." 4
by out arity: mOutArity
.PP
.IP "2." 4
by Conjunctions: using SparseConstraints::operator<(Exp) 
.PP
\fBParameters\fP
.RS 4
\fIother,object\fP to be compared 
.RE
.PP

.PP

.SS "\fBRelation\fP & iegenlib::Relation::operator= (\fBconst\fP \fBRelation\fP & other)"

.SS "\fBRelation\fP & iegenlib::Relation::operator= (\fBconst\fP \fBSet\fP & other)"

.SS "bool iegenlib::Relation::operator== (\fBconst\fP \fBRelation\fP & other) const"

.PP
Equals operator\&. Equals operator\&. if self < other return false if other < self return false return true
.PP
\fBParameters\fP
.RS 4
\fIother,object\fP to be compared 
.RE
.PP

.SS "int iegenlib::Relation::outArity () const\fC [inline]\fP"

.SS "std::string iegenlib::Relation::prettyPrintString () const\fC [virtual]\fP"

.PP
Convert to a human-readable string (substitute in tuple vars)\&. 
.PP
Reimplemented from \fBiegenlib::SparseConstraints\fP\&.
.SS "\fBRelation\fP * iegenlib::Relation::projectOut (int tvar)"
Projects out tuple var No\&. tvar, if it is not an argument to a UFCall\&. If tvar is an argument to some UFCall, then returns NULL\&.
.PP
Projects out tuple varrable No\&. tvar if tvar is not argument to any UFCall tvar is calculated based on total ariety (in+out) starting from 0\&. Consequently, to project out jp from R: tvar = 5 R = {[i,j,k] -> [ip,jp,kp] : \&.\&.\&.}
.PP
NOTE: if tvar is argument some UFCall, then we cannot project it out and functions returns NULL\&. Ex: if \fBcol(k)\fP in constraints exists we cannot project out 'k' 
.SS "\fBRelation\fP * iegenlib::Relation::reverseAffineSubstitution (\fBUFCallMap\fP * ufcmap)"

.PP
Same as \fBSet\fP\&. Creates a sub non-affine set from an affine \fBRelation\fP\&. By replacing symbolic constants that are representative of UFCalls with their respective UFCalls\&. The function does not own the ufcmap\&. Caller must cleanup returned \fBRelation\fP\&. 
.SS "void iegenlib::Relation::SetinArity (int in)\fC [inline]\fP"

.SS "void iegenlib::Relation::SetoutArity (int out)\fC [inline]\fP"

.SS "void iegenlib::Relation::setTupleDecl (\fBTupleDecl\fP tuple_decl)\fC [virtual]\fP"
For all conjunctions, sets them to the given tuple declaration\&. If there are some constants that don't agree then throws exception\&. If replacing a constant with a variable ignores the substitution in that conjunction\&. Also modifies arity to match\&. FIXME: MMS 10/21/15, why do we need this?
.PP
For all conjunctions, sets them to the given tuple declaration\&. If there are some constants that don't agree then throws exception\&. If replacing a constant with a variable ignores the substitution in that conjunction\&. Also modifies arity to match\&. 
.PP
Reimplemented from \fBiegenlib::SparseConstraints\fP\&.
.SS "\fBRelation\fP * iegenlib::Relation::simplifyForPartialParallel (\fBstd::set\fP< int > parallelTvs)"
This function simplifies constraints sets of non-affine sets that are targeted for level set parallelism\&. These sets are representative of data access dependency relations\&. For level set parallelism, we need to create an optimized inspector code that checks data dependency based these constraints in run time\&. This function is implementation of Simplification Algorithm that simplifies dependency relations, so we can generate optimized inspector code from constraint sets\&.
.PP
Same as \fBSet\fP\&. 
.SS "\fBRelation\fP * iegenlib::Relation::superAffineRelation ()"

.SS "\fBRelation\fP * iegenlib::Relation::superAffineRelation (\fBUFCallMap\fP * ufcmap, bool boundUFCs = \fCtrue\fP)"

.PP
Same as \fBSet\fP\&. Creates a super affine \fBRelation\fP from a non-affine \fBRelation\fP\&. To do this: (1) OPTIONAL: We add constraints due to all UFCalls' domain and range (2) We replace all UFCalls with symbolic constants in the ufc map\&. ufcmap: is going to pupulated with UFCs and their eq\&. symbolic constants it can be later used to replace back the UFCs with reverseAffineSubstitution boundUFCs: for most purposes we probably want to bound domain and range 
.br
 of UFCalls in a set before turning it into a super affine set\&. However, sometimes it might be desiarable not to do that, e\&.g in rule instantiation The function does not own the ufcmap\&. 
.SS "std::string iegenlib::Relation::toDotString () const\fC [virtual]\fP"
Create a string for use with the GraphViz tool dot so we can visualize the \fBRelation\fP data structure\&. 
.PP
Reimplemented from \fBiegenlib::SparseConstraints\fP\&.
.SS "std::string iegenlib::Relation::toString () const\fC [virtual]\fP"

.PP
Convert to a human-readable string\&. 
.PP
Reimplemented from \fBiegenlib::SparseConstraints\fP\&.
.SS "\fBRelation\fP * iegenlib::Relation::Union (\fBconst\fP \fBRelation\fP * rhs) const"
Union this relation with the given other one (i\&.e\&., the Union rhs)\&. Returns a new \fBRelation\fP, which the caller is responsible for deallocating\&. 
.PP
\fBParameters\fP
.RS 4
\fIrhs\fP (not adopted)
.RE
.PP
Union this relation with the given other one (i\&.e\&., this Union rhs)\&. Returns a new \fBRelation\fP, which the caller is responsible for deallocating\&. 
.PP
\fBParameters\fP
.RS 4
\fIrhs\fP (not adopted) 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
