.TH "lib/chill/omega/parser/lex.yy.cc" 3 "Sun Jul 12 2020" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/chill/omega/parser/lex.yy.cc
.SH SYNOPSIS
.br
.PP
\fC#include <iostream>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <cstdlib>\fP
.br
\fC#include <cstdio>\fP
.br
\fC#include <cstring>\fP
.br
\fC#include <FlexLexer\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <string>\fP
.br
\fC#include <sstream>\fP
.br
\fC#include <fstream>\fP
.br
\fC#include <omega/parser/AST\&.hh>\fP
.br
\fC#include <basic/Dynamic_Array\&.h>\fP
.br
\fC#include 'parser\&.tab\&.hh'\fP
.br
\fC#include <unistd\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fByy_buffer_state\fP"
.br
.ti -1c
.RI "struct \fByy_trans_info\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBYY_INT_ALIGNED\fP   short int"
.br
.ti -1c
.RI "#define \fBFLEX_SCANNER\fP"
.br
.ti -1c
.RI "#define \fBYY_FLEX_MAJOR_VERSION\fP   2"
.br
.ti -1c
.RI "#define \fBYY_FLEX_MINOR_VERSION\fP   6"
.br
.ti -1c
.RI "#define \fBYY_FLEX_SUBMINOR_VERSION\fP   4"
.br
.ti -1c
.RI "#define \fBFLEX_BETA\fP"
.br
.ti -1c
.RI "#define \fBFLEXINT_H\fP"
.br
.ti -1c
.RI "#define \fBINT8_MIN\fP   (\-128)"
.br
.ti -1c
.RI "#define \fBINT16_MIN\fP   (\-32767\-1)"
.br
.ti -1c
.RI "#define \fBINT32_MIN\fP   (\-2147483647\-1)"
.br
.ti -1c
.RI "#define \fBINT8_MAX\fP   (127)"
.br
.ti -1c
.RI "#define \fBINT16_MAX\fP   (32767)"
.br
.ti -1c
.RI "#define \fBINT32_MAX\fP   (2147483647)"
.br
.ti -1c
.RI "#define \fBUINT8_MAX\fP   (255\fBU\fP)"
.br
.ti -1c
.RI "#define \fBUINT16_MAX\fP   (65535\fBU\fP)"
.br
.ti -1c
.RI "#define \fBUINT32_MAX\fP   (4294967295\fBU\fP)"
.br
.ti -1c
.RI "#define \fBSIZE_MAX\fP   (~(size_t)0)"
.br
.ti -1c
.RI "#define \fByyconst\fP   \fBconst\fP"
.br
.ti -1c
.RI "#define \fByynoreturn\fP"
.br
.ti -1c
.RI "#define \fBYY_NULL\fP   0"
.br
.ti -1c
.RI "#define \fBYY_SC_TO_UI\fP(\fBc\fP)   ((\fBYY_CHAR\fP) (\fBc\fP))"
.br
.ti -1c
.RI "#define \fBBEGIN\fP   (yy_start) = 1 + 2 *"
.br
.ti -1c
.RI "#define \fBYY_START\fP   (((yy_start) \- 1) / 2)"
.br
.ti -1c
.RI "#define \fBYYSTATE\fP   \fBYY_START\fP"
.br
.ti -1c
.RI "#define \fBYY_STATE_EOF\fP(state)   (\fBYY_END_OF_BUFFER\fP + state + 1)"
.br
.ti -1c
.RI "#define \fBYY_NEW_FILE\fP   \fByyrestart\fP( \fByyin\fP  )"
.br
.ti -1c
.RI "#define \fBYY_END_OF_BUFFER_CHAR\fP   0"
.br
.ti -1c
.RI "#define \fBYY_BUF_SIZE\fP   16384"
.br
.ti -1c
.RI "#define \fBYY_STATE_BUF_SIZE\fP   ((\fBYY_BUF_SIZE\fP + 2) * sizeof(\fByy_state_type\fP))"
.br
.ti -1c
.RI "#define \fBYY_TYPEDEF_YY_BUFFER_STATE\fP"
.br
.ti -1c
.RI "#define \fBYY_TYPEDEF_YY_SIZE_T\fP"
.br
.ti -1c
.RI "#define \fBEOB_ACT_CONTINUE_SCAN\fP   0"
.br
.ti -1c
.RI "#define \fBEOB_ACT_END_OF_FILE\fP   1"
.br
.ti -1c
.RI "#define \fBEOB_ACT_LAST_MATCH\fP   2"
.br
.ti -1c
.RI "#define \fBYY_LESS_LINENO\fP(\fBn\fP)"
.br
.ti -1c
.RI "#define \fBYY_LINENO_REWIND_TO\fP(dst)"
.br
.ti -1c
.RI "#define \fByyless\fP(\fBn\fP)"
.br
.ti -1c
.RI "#define \fBunput\fP(\fBc\fP)   yyunput( \fBc\fP, (\fByytext_ptr\fP)  )"
.br
.ti -1c
.RI "#define \fBYY_STRUCT_YY_BUFFER_STATE\fP"
.br
.ti -1c
.RI "#define \fBYY_BUFFER_NEW\fP   0"
.br
.ti -1c
.RI "#define \fBYY_BUFFER_NORMAL\fP   1"
.br
.ti -1c
.RI "#define \fBYY_BUFFER_EOF_PENDING\fP   2"
.br
.ti -1c
.RI "#define \fBYY_CURRENT_BUFFER\fP"
.br
.ti -1c
.RI "#define \fBYY_CURRENT_BUFFER_LVALUE\fP   (yy_buffer_stack)[(yy_buffer_stack_top)]"
.br
.ti -1c
.RI "#define \fByy_new_buffer\fP   \fByy_create_buffer\fP"
.br
.ti -1c
.RI "#define \fByy_set_interactive\fP(\fBis_interactive\fP)"
.br
.ti -1c
.RI "#define \fByy_set_bol\fP(at_bol)"
.br
.ti -1c
.RI "#define \fBYY_AT_BOL\fP()   (\fBYY_CURRENT_BUFFER_LVALUE\fP\->yy_at_bol)"
.br
.ti -1c
.RI "#define \fBYY_SKIP_YYWRAP\fP"
.br
.ti -1c
.RI "#define \fByytext_ptr\fP   \fByytext\fP"
.br
.ti -1c
.RI "#define \fBYY_INTERACTIVE\fP"
.br
.ti -1c
.RI "#define \fBYY_DO_BEFORE_ACTION\fP"
.br
.ti -1c
.RI "#define \fBYY_NUM_RULES\fP   147"
.br
.ti -1c
.RI "#define \fBYY_END_OF_BUFFER\fP   148"
.br
.ti -1c
.RI "#define \fBREJECT\fP   reject_used_but_not_detected"
.br
.ti -1c
.RI "#define \fByymore\fP()   yymore_used_but_not_detected"
.br
.ti -1c
.RI "#define \fBYY_MORE_ADJ\fP   0"
.br
.ti -1c
.RI "#define \fBYY_RESTORE_YY_MORE_OFFSET\fP"
.br
.ti -1c
.RI "#define \fBBUFFER\fP   \fBscanBuf\fP += \fByytext\fP"
.br
.ti -1c
.RI "#define \fBINITIAL\fP   0"
.br
.ti -1c
.RI "#define \fBLATEX\fP   1"
.br
.ti -1c
.RI "#define \fBINCLUDE\fP   2"
.br
.ti -1c
.RI "#define \fBCOMMENT\fP   3"
.br
.ti -1c
.RI "#define \fBYY_EXTRA_TYPE\fP   void *"
.br
.ti -1c
.RI "#define \fBYY_READ_BUF_SIZE\fP   8192"
.br
.ti -1c
.RI "#define \fBECHO\fP   LexerOutput( \fByytext\fP, \fByyleng\fP )"
.br
.ti -1c
.RI "#define \fBYY_INPUT\fP(buf,  result,  max_size)"
.br
.ti -1c
.RI "#define \fByyterminate\fP()   return \fBYY_NULL\fP"
.br
.ti -1c
.RI "#define \fBYY_START_STACK_INCR\fP   25"
.br
.ti -1c
.RI "#define \fBYY_FATAL_ERROR\fP(msg)   LexerError( msg )"
.br
.ti -1c
.RI "#define \fBYY_DECL_IS_OURS\fP   1"
.br
.ti -1c
.RI "#define \fBYY_DECL\fP   int \fByyFlexLexer::yylex\fP()"
.br
.ti -1c
.RI "#define \fBYY_USER_ACTION\fP"
.br
.ti -1c
.RI "#define \fBYY_BREAK\fP   /*LINTED*/break;"
.br
.ti -1c
.RI "#define \fBYY_RULE_SETUP\fP   \fBYY_USER_ACTION\fP"
.br
.ti -1c
.RI "#define \fBYY_EXIT_FAILURE\fP   2"
.br
.ti -1c
.RI "#define \fByyless\fP(\fBn\fP)"
.br
.ti -1c
.RI "#define \fBYYTABLES_NAME\fP   'yytables'"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef signed char \fBflex_int8_t\fP"
.br
.ti -1c
.RI "typedef short int \fBflex_int16_t\fP"
.br
.ti -1c
.RI "typedef int \fBflex_int32_t\fP"
.br
.ti -1c
.RI "typedef unsigned char \fBflex_uint8_t\fP"
.br
.ti -1c
.RI "typedef unsigned short int \fBflex_uint16_t\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBflex_uint32_t\fP"
.br
.ti -1c
.RI "typedef struct \fByy_buffer_state\fP * \fBYY_BUFFER_STATE\fP"
.br
.ti -1c
.RI "typedef size_t \fByy_size_t\fP"
.br
.ti -1c
.RI "typedef \fBflex_uint8_t\fP \fBYY_CHAR\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void * \fByyalloc\fP (\fByy_size_t\fP)"
.br
.ti -1c
.RI "void * \fByyrealloc\fP (void *, \fByy_size_t\fP)"
.br
.ti -1c
.RI "void \fByyfree\fP (void *)"
.br
.ti -1c
.RI "void \fByyerror\fP (\fBconst\fP std::string &s)"
.br
.ti -1c
.RI "void \fBflushScanBuffer\fP ()"
.br
.ti -1c
.RI "\fBif\fP (!(yy_init))"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fByyleng\fP"
.br
.ti -1c
.RI "yyFlexLexer \fBmylexer\fP"
.br
.ti -1c
.RI "bool \fBis_interactive\fP"
.br
.ti -1c
.RI "\fBconst\fP char * \fBPROMPT_STRING\fP = '>>>'"
.br
.ti -1c
.RI "std::string \fBscanBuf\fP"
.br
.ti -1c
.RI "std::string \fBerr_msg\fP"
.br
.ti -1c
.RI "bool \fBneed_coef\fP"
.br
.ti -1c
.RI "\fBYY_DECL\fP"
.br
.ti -1c
.RI "char * \fByy_cp\fP"
.br
.ti -1c
.RI "char * \fByy_bp\fP"
.br
.ti -1c
.RI "int \fByy_act\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define BEGIN   (yy_start) = 1 + 2 *"

.SS "#define BUFFER   \fBscanBuf\fP += \fByytext\fP"

.SS "#define COMMENT   3"

.SS "#define ECHO   LexerOutput( \fByytext\fP, \fByyleng\fP )"

.SS "#define EOB_ACT_CONTINUE_SCAN   0"

.SS "#define EOB_ACT_END_OF_FILE   1"

.SS "#define EOB_ACT_LAST_MATCH   2"

.SS "#define FLEX_BETA"

.SS "#define FLEX_SCANNER"

.SS "#define FLEXINT_H"

.SS "#define INCLUDE   2"

.SS "#define INITIAL   0"

.SS "#define INT16_MAX   (32767)"

.SS "#define INT16_MIN   (\-32767\-1)"

.SS "#define INT32_MAX   (2147483647)"

.SS "#define INT32_MIN   (\-2147483647\-1)"

.SS "#define INT8_MAX   (127)"

.SS "#define INT8_MIN   (\-128)"

.SS "#define LATEX   1"

.SS "#define REJECT   reject_used_but_not_detected"

.SS "#define SIZE_MAX   (~(size_t)0)"

.SS "#define UINT16_MAX   (65535\fBU\fP)"

.SS "#define UINT32_MAX   (4294967295\fBU\fP)"

.SS "#define UINT8_MAX   (255\fBU\fP)"

.SS "#define unput(\fBc\fP)   yyunput( \fBc\fP, (\fByytext_ptr\fP)  )"

.SS "#define YY_AT_BOL()   (\fBYY_CURRENT_BUFFER_LVALUE\fP\->yy_at_bol)"

.SS "#define YY_BREAK   /*LINTED*/break;"

.SS "#define YY_BUF_SIZE   16384"

.SS "#define YY_BUFFER_EOF_PENDING   2"

.SS "#define YY_BUFFER_NEW   0"

.SS "#define YY_BUFFER_NORMAL   1"

.SS "#define YY_CURRENT_BUFFER"
\fBValue:\fP
.PP
.nf
                          ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)
.fi
.SS "#define YY_CURRENT_BUFFER_LVALUE   (yy_buffer_stack)[(yy_buffer_stack_top)]"

.SS "#define YY_DECL   int \fByyFlexLexer::yylex\fP()"

.SS "#define YY_DECL_IS_OURS   1"

.SS "#define YY_DO_BEFORE_ACTION"
\fBValue:\fP
.PP
.nf
  (yytext_ptr) = yy_bp; \
    yyleng = (int) (yy_cp - yy_bp); \
    (yy_hold_char) = *yy_cp; \
    *yy_cp = '\0'; \
    (yy_c_buf_p) = yy_cp;
.fi
.SS "#define YY_END_OF_BUFFER   148"

.SS "#define YY_END_OF_BUFFER_CHAR   0"

.SS "#define YY_EXIT_FAILURE   2"

.SS "#define YY_EXTRA_TYPE   void *"

.SS "#define YY_FATAL_ERROR(msg)   LexerError( msg )"

.SS "#define YY_FLEX_MAJOR_VERSION   2"

.SS "#define YY_FLEX_MINOR_VERSION   6"

.SS "#define YY_FLEX_SUBMINOR_VERSION   4"

.SS "#define YY_INPUT(buf, result, max_size)"
\fBValue:\fP
.PP
.nf
\
    if ( (int)(result = LexerInput( (char *) buf, max_size )) < 0 ) \
        YY_FATAL_ERROR( "input in flex scanner failed" );
.fi
.SS "#define YY_INT_ALIGNED   short int"

.SS "#define YY_INTERACTIVE"

.SS "#define YY_LESS_LINENO(\fBn\fP)"
\fBValue:\fP
.PP
.nf
            do { \
                int yyl;\
                for ( yyl = n; yyl < yyleng; ++yyl )\
                    if ( yytext[yyl] == '\n' )\
                        --yylineno;\
            }while(0)
.fi
.SS "#define YY_LINENO_REWIND_TO(dst)"
\fBValue:\fP
.PP
.nf
            do {\
                const char *p;\
                for ( p = yy_cp-1; p >= (dst); --p)\
                    if ( *p == '\n' )\
                        --yylineno;\
            }while(0)
.fi
.SS "#define YY_MORE_ADJ   0"

.SS "#define yy_new_buffer   \fByy_create_buffer\fP"

.SS "#define YY_NEW_FILE   \fByyrestart\fP( \fByyin\fP  )"

.SS "#define YY_NULL   0"

.SS "#define YY_NUM_RULES   147"

.SS "#define YY_READ_BUF_SIZE   8192"

.SS "#define YY_RESTORE_YY_MORE_OFFSET"

.SS "#define YY_RULE_SETUP   \fBYY_USER_ACTION\fP"

.SS "#define YY_SC_TO_UI(\fBc\fP)   ((\fBYY_CHAR\fP) (\fBc\fP))"

.SS "#define yy_set_bol(at_bol)"
\fBValue:\fP
.PP
.nf
    { \
    if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
        YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
    } \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
    }
.fi
.SS "#define yy_set_interactive(\fBis_interactive\fP)"
\fBValue:\fP
.PP
.nf
  { \
    if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
        YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
    } \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
    }
.fi
.SS "#define YY_SKIP_YYWRAP"

.SS "#define YY_START   (((yy_start) \- 1) / 2)"

.SS "#define YY_START_STACK_INCR   25"

.SS "#define YY_STATE_BUF_SIZE   ((\fBYY_BUF_SIZE\fP + 2) * sizeof(\fByy_state_type\fP))"

.SS "#define YY_STATE_EOF(state)   (\fBYY_END_OF_BUFFER\fP + state + 1)"

.SS "#define YY_STRUCT_YY_BUFFER_STATE"

.SS "#define YY_TYPEDEF_YY_BUFFER_STATE"

.SS "#define YY_TYPEDEF_YY_SIZE_T"

.SS "#define YY_USER_ACTION"

.SS "#define yyconst   \fBconst\fP"

.SS "#define yyless(\fBn\fP)"
\fBValue:\fP
.PP
.nf
 do \
        { \
        /* Undo effects of setting up yytext\&. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
        *yy_cp = (yy_hold_char); \
        YY_RESTORE_YY_MORE_OFFSET \
        (yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
        YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        } \
    while ( 0 )
.fi
.SS "#define yyless(\fBn\fP)"
\fBValue:\fP
.PP
.nf
   do \
        { \
        /* Undo effects of setting up yytext\&. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
        yytext[yyleng] = (yy_hold_char); \
        (yy_c_buf_p) = yytext + yyless_macro_arg; \
        (yy_hold_char) = *(yy_c_buf_p); \
        *(yy_c_buf_p) = '\0'; \
        yyleng = yyless_macro_arg; \
        } \
    while ( 0 )
.fi
.SS "#define yymore()   yymore_used_but_not_detected"

.SS "#define yynoreturn"

.SS "#define YYSTATE   \fBYY_START\fP"

.SS "#define YYTABLES_NAME   'yytables'"

.SS "#define yyterminate()   return \fBYY_NULL\fP"

.SS "#define yytext_ptr   \fByytext\fP"

.SH "Typedef Documentation"
.PP 
.SS "typedef short int \fBflex_int16_t\fP"

.SS "typedef int \fBflex_int32_t\fP"

.SS "typedef signed char \fBflex_int8_t\fP"

.SS "typedef unsigned short int \fBflex_uint16_t\fP"

.SS "typedef unsigned int \fBflex_uint32_t\fP"

.SS "typedef unsigned char \fBflex_uint8_t\fP"

.SS "typedef struct \fByy_buffer_state\fP* \fBYY_BUFFER_STATE\fP"

.SS "typedef \fBflex_uint8_t\fP \fBYY_CHAR\fP"

.SS "typedef size_t \fByy_size_t\fP"

.SH "Function Documentation"
.PP 
.SS "void flushScanBuffer ()"

.SS "if (!yy_init)"

.SS "void* \fByyalloc\fP (\fByy_size_t\fP)"

.SS "void yyerror (\fBconst\fP std::string & s)"

.SS "void yyfree (void *)"

.SS "void* yyrealloc (void *, \fByy_size_t\fP)"

.SH "Variable Documentation"
.PP 
.SS "std::string err_msg"

.SS "bool is_interactive"

.SS "yyFlexLexer mylexer"

.SS "bool need_coef"

.SS "\fBconst\fP char* PROMPT_STRING = '>>>'"

.SS "std::string scanBuf"

.SS "int yy_act"

.SS "char * yy_bp"

.SS "char* yy_cp"

.SS "YY_DECL"
\fBInitial value:\fP
.PP
.nf
{
    yy_state_type yy_current_state
.fi
The main scanner function which does all the work\&. 
.SS "int yyleng"

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
