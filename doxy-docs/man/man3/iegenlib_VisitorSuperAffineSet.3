.TH "iegenlib::VisitorSuperAffineSet" 3 "Sun Jul 12 2020" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
iegenlib::VisitorSuperAffineSet
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBVisitor\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVisitorSuperAffineSet\fP (\fBUFCallMap\fP *imap)"
.br
.ti -1c
.RI "void \fBpreVisitTerm\fP (\fBTerm\fP *t)"
.br
.ti -1c
.RI "void \fBpreVisitUFCallTerm\fP (\fBUFCallTerm\fP *t)"
.br
.ti -1c
.RI "void \fBpreVisitTupleVarTerm\fP (\fBTupleVarTerm\fP *t)"
.br
.ti -1c
.RI "void \fBpreVisitVarTerm\fP (\fBVarTerm\fP *t)"
.br
.ti -1c
.RI "void \fBpreVisitTupleExpTerm\fP (\fBTupleExpTerm\fP *t)"
.br
.ti -1c
.RI "void \fBpreVisitExp\fP (\fBiegenlib::Exp\fP *\fBe\fP)"
.br
.ti -1c
.RI "void \fBpostVisitExp\fP (\fBiegenlib::Exp\fP *\fBe\fP)"
.br
.ti -1c
.RI "void \fBpreVisitConjunction\fP (\fBiegenlib::Conjunction\fP *\fBc\fP)"
.br
.RI "Initializes an affineConj\&. "
.ti -1c
.RI "void \fBpostVisitConjunction\fP (\fBiegenlib::Conjunction\fP *\fBc\fP)"
.br
.RI "adds the current affineConj to maffineConj "
.ti -1c
.RI "void \fBpostVisitSet\fP (\fBiegenlib::Set\fP *s)"
.br
.RI "Add Conjunctions in maffineConj to affineSet\&. "
.ti -1c
.RI "void \fBpostVisitRelation\fP (\fBiegenlib::Relation\fP *r)"
.br
.RI "Add Conjunctions in maffineConj to affineRelation\&. "
.ti -1c
.RI "\fBSet\fP * \fBgetSet\fP ()"
.br
.ti -1c
.RI "\fBRelation\fP * \fBgetRelation\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
Vistor Class used in SuperAffineSet Used in traversing a Set/Relation to replace UFCs with symbolic constants We will build up a affineSet (or affineRelation), term by term\&. And if a term is UFCall, we will convert it to symbolic constant, which is pre-computed and stored in the ufcmap 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "iegenlib::VisitorSuperAffineSet::VisitorSuperAffineSet (\fBUFCallMap\fP * imap)\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBRelation\fP* iegenlib::VisitorSuperAffineSet::getRelation ()\fC [inline]\fP"

.SS "\fBSet\fP* iegenlib::VisitorSuperAffineSet::getSet ()\fC [inline]\fP"

.SS "void iegenlib::VisitorSuperAffineSet::postVisitConjunction (\fBiegenlib::Conjunction\fP * c)\fC [inline]\fP, \fC [virtual]\fP"

.PP
adds the current affineConj to maffineConj 
.PP
Reimplemented from \fBVisitor\fP\&.
.SS "void iegenlib::VisitorSuperAffineSet::postVisitExp (\fBiegenlib::Exp\fP * e)\fC [inline]\fP, \fC [virtual]\fP"
We don't care about e's that are argument to an UFCall Nonetheless, we should set visit = true, because of the nested expressions: we are care about the whole expression i = row(j+1) but not the sub-expression (j+1) that an is argument to row\&. 
.PP
Reimplemented from \fBVisitor\fP\&.
.SS "void iegenlib::VisitorSuperAffineSet::postVisitRelation (\fBiegenlib::Relation\fP * r)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Add Conjunctions in maffineConj to affineRelation\&. 
.PP
Reimplemented from \fBVisitor\fP\&.
.SS "void iegenlib::VisitorSuperAffineSet::postVisitSet (\fBiegenlib::Set\fP * s)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Add Conjunctions in maffineConj to affineSet\&. 
.PP
Reimplemented from \fBVisitor\fP\&.
.SS "void iegenlib::VisitorSuperAffineSet::preVisitConjunction (\fBiegenlib::Conjunction\fP * c)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Initializes an affineConj\&. 
.PP
Reimplemented from \fBVisitor\fP\&.
.SS "void iegenlib::VisitorSuperAffineSet::preVisitExp (\fBiegenlib::Exp\fP * e)\fC [inline]\fP, \fC [virtual]\fP"
Intialize an affineExp if \fBExp\fP is not a UFCall argument If this is a argument to a UFCall, we don't want to modify it\&. This is because A(B(i+1)) gets replaced with A_B_iP1__ without doing anything about B(i+1)\&. And keep in mind that we have already added constraints related to function B's domain and range\&. 
.PP
Reimplemented from \fBVisitor\fP\&.
.SS "void iegenlib::VisitorSuperAffineSet::preVisitTerm (\fBTerm\fP * t)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBVisitor\fP\&.
.SS "void iegenlib::VisitorSuperAffineSet::preVisitTupleExpTerm (\fBTupleExpTerm\fP * t)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBVisitor\fP\&.
.SS "void iegenlib::VisitorSuperAffineSet::preVisitTupleVarTerm (\fBTupleVarTerm\fP * t)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBVisitor\fP\&.
.SS "void iegenlib::VisitorSuperAffineSet::preVisitUFCallTerm (\fBUFCallTerm\fP * t)\fC [inline]\fP, \fC [virtual]\fP"
We iterate over terms in \fBExp\fP, if the term is not a UFCall then we just add it to our affine set\&. On the other hand, We need to turn UFCalls into symbolic constants to make an affine set\&. 
.PP
Reimplemented from \fBVisitor\fP\&.
.SS "void iegenlib::VisitorSuperAffineSet::preVisitVarTerm (\fBVarTerm\fP * t)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBVisitor\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
