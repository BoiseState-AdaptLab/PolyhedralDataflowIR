.TH "lib/chill/irtools.hh" 3 "Sun Jul 12 2020" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/chill/irtools.hh \- Useful tools to analyze code in compiler IR format\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <vector>\fP
.br
\fC#include <omega\&.h>\fP
.br
\fC#include <code_gen/CG_outputRepr\&.h>\fP
.br
\fC#include 'ir_code\&.hh'\fP
.br
\fC#include 'dep\&.hh'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBir_tree_node\fP"
.br
.RI "IR tree is used to initialize a loop\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDEP_DEBUG\fP   0"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fBstd::map\fP< int, std::pair< std::vector< \fBDependenceVector\fP >, std::vector< \fBDependenceVector\fP > > > \fBtempResultMap\fP"
.br
.ti -1c
.RI "typedef std::pair< std::vector< \fBDependenceVector\fP >, std::vector< \fBDependenceVector\fP > > \fBDVPair\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "std::vector< \fBir_tree_node\fP * > \fBbuild_ir_tree\fP (\fBIR_Control\fP *control, \fBir_tree_node\fP *parent=\fBNULL\fP)"
.br
.RI "Build IR tree from the source code\&. "
.ti -1c
.RI "std::vector< \fBir_tree_node\fP * > \fBextract_ir_stmts\fP (\fBconst\fP std::vector< \fBir_tree_node\fP * > &ir_tree)"
.br
.RI "Extract statements from IR tree\&. "
.ti -1c
.RI "bool \fBis_dependence_valid\fP (\fBir_tree_node\fP *src_node, \fBir_tree_node\fP *dst_node, \fBconst\fP \fBDependenceVector\fP &dv, bool before)"
.br
.ti -1c
.RI "std::pair< std::vector< \fBDependenceVector\fP >, std::vector< \fBDependenceVector\fP > > \fBtest_data_dependences\fP (\fBLoop\fP *loop, \fBIR_Code\fP *ir, \fBconst\fP \fBomega::CG_outputRepr\fP *repr1, \fBconst\fP \fBomega::Relation\fP &IS1, \fBconst\fP \fBomega::CG_outputRepr\fP *repr2, \fBconst\fP \fBomega::Relation\fP &IS2, std::vector< \fBomega::Free_Var_Decl\fP * > &freevar, std::vector< std::string > index, int nestLeveli, int nestLevelj, \fBstd::map\fP< std::string, std::vector< \fBomega::CG_outputRepr\fP * > > &uninterpreted_symbols, \fBstd::map\fP< std::string, std::vector< \fBomega::CG_outputRepr\fP * > > &uninterpreted_symbols_stringrepr, \fBstd::map\fP< std::string, std::vector< \fBomega::Relation\fP > > &unin_rel, std::vector< \fBomega::Relation\fP > &dep_relation)"
.br
.RI "test data dependeces between two statements "
.ti -1c
.RI "std::vector< \fBomega::CG_outputRepr\fP * > \fBcollect_loop_inductive_and_conditionals\fP (\fBir_tree_node\fP *stmt_node)"
.br
.ti -1c
.RI "bool \fBfrom_same_statement\fP (\fBIR_Code\fP *ir, \fBIR_ArrayRef\fP *\fBa\fP, \fBIR_ArrayRef\fP *\fBb\fP)"
.br
.ti -1c
.RI "int \fBstmtType\fP (\fBIR_Code\fP *ir, \fBconst\fP \fBomega::CG_outputRepr\fP *repr)"
.br
.ti -1c
.RI "\fBIR_OPERATION_TYPE\fP \fBgetReductionOperator\fP (\fBIR_Code\fP *ir, \fBconst\fP \fBomega::CG_outputRepr\fP *repr)"
.br
.ti -1c
.RI "void \fBmapRefstoStatements\fP (\fBIR_Code\fP *ir, std::vector< \fBIR_ArrayRef\fP * > access, int ref2Stmt[], \fBstd::map\fP< int, \fBstd::set\fP< int > > &rMap, \fBstd::set\fP< int > &tnrStmts, \fBstd::set\fP< int > &nrStmts)"
.br
.ti -1c
.RI "void \fBcheckReductionDependence\fP (int \fBi\fP, int \fBj\fP, int nestLeveli, \fBomega::coef_t\fP lbound[], \fBomega::coef_t\fP ubound[], int ref2Stmt[], \fBstd::map\fP< int, \fBstd::set\fP< int > > &rMap, \fBDVPair\fP &dv, \fBtempResultMap\fP &trMap, \fBstd::set\fP< int > nrStmts)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Useful tools to analyze code in compiler IR format\&. 


.SH "Macro Definition Documentation"
.PP 
.SS "#define DEP_DEBUG   0"

.SH "Typedef Documentation"
.PP 
.SS "typedef std::pair<std::vector<\fBDependenceVector\fP>, std::vector<\fBDependenceVector\fP> > \fBDVPair\fP"

.SS "typedef \fBstd::map\fP<int, std::pair<std::vector<\fBDependenceVector\fP>, std::vector<\fBDependenceVector\fP> > > \fBtempResultMap\fP"

.SH "Function Documentation"
.PP 
.SS "std::vector<\fBir_tree_node\fP *> build_ir_tree (\fBIR_Control\fP * control, \fBir_tree_node\fP * parent = \fC\fBNULL\fP\fP)"

.PP
Build IR tree from the source code\&. Block type node can only be leaf, i\&.e\&., there is no further stuctures inside a block allowed
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP 
.br
\fIparent\fP 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.SS "void checkReductionDependence (int i, int j, int nestLeveli, \fBomega::coef_t\fP lbound[], \fBomega::coef_t\fP ubound[], int ref2Stmt[], \fBstd::map\fP< int, \fBstd::set\fP< int > > & rMap, \fBDVPair\fP & dv, \fBtempResultMap\fP & trMap, \fBstd::set\fP< int > nrStmts)"

.SS "std::vector<\fBomega::CG_outputRepr\fP *> collect_loop_inductive_and_conditionals (\fBir_tree_node\fP * stmt_node)"

.SS "std::vector<\fBir_tree_node\fP *> extract_ir_stmts (\fBconst\fP std::vector< \fBir_tree_node\fP * > & ir_tree)"

.PP
Extract statements from IR tree\&. Statements returned are ordered in lexical order in the source code
.PP
\fBParameters\fP
.RS 4
\fIir_tree\fP 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.SS "bool from_same_statement (\fBIR_Code\fP * ir, \fBIR_ArrayRef\fP * a, \fBIR_ArrayRef\fP * b)"

.SS "\fBIR_OPERATION_TYPE\fP getReductionOperator (\fBIR_Code\fP * ir, \fBconst\fP \fBomega::CG_outputRepr\fP * repr)"

.SS "bool is_dependence_valid (\fBir_tree_node\fP * src_node, \fBir_tree_node\fP * dst_node, \fBconst\fP \fBDependenceVector\fP & dv, bool before)"

.SS "void mapRefstoStatements (\fBIR_Code\fP * ir, std::vector< \fBIR_ArrayRef\fP * > access, int ref2Stmt[], \fBstd::map\fP< int, \fBstd::set\fP< int > > & rMap, \fBstd::set\fP< int > & tnrStmts, \fBstd::set\fP< int > & nrStmts)"

.SS "int stmtType (\fBIR_Code\fP * ir, \fBconst\fP \fBomega::CG_outputRepr\fP * repr)"

.SS "std::pair<std::vector<\fBDependenceVector\fP>, std::vector<\fBDependenceVector\fP> > test_data_dependences (\fBLoop\fP * loop, \fBIR_Code\fP * ir, \fBconst\fP \fBomega::CG_outputRepr\fP * repr1, \fBconst\fP \fBomega::Relation\fP & IS1, \fBconst\fP \fBomega::CG_outputRepr\fP * repr2, \fBconst\fP \fBomega::Relation\fP & IS2, std::vector< \fBomega::Free_Var_Decl\fP * > & freevar, std::vector< std::string > index, int nestLeveli, int nestLevelj, \fBstd::map\fP< std::string, std::vector< \fBomega::CG_outputRepr\fP * > > & uninterpreted_symbols, \fBstd::map\fP< std::string, std::vector< \fBomega::CG_outputRepr\fP * > > & uninterpreted_symbols_stringrepr, \fBstd::map\fP< std::string, std::vector< \fBomega::Relation\fP > > & unin_rel, std::vector< \fBomega::Relation\fP > & dep_relation)"

.PP
test data dependeces between two statements The first statement in parameter must be lexically before the second statement in parameter\&. Returned dependences are all lexicographically positive
.PP
\fBParameters\fP
.RS 4
\fIloop\fP 
.br
\fIir\fP 
.br
\fIrepr1\fP 
.br
\fIIS1\fP 
.br
\fIrepr2\fP 
.br
\fIIS2\fP 
.br
\fIfreevar\fP 
.br
\fIindex\fP 
.br
\fInestLeveli\fP 
.br
\fInestLevelj\fP 
.br
\fIuninterpreted_symbols\fP 
.br
\fIuninterpreted_symbols_stringrepr\fP 
.br
\fIunin_rel\fP 
.br
\fIdep_relation\fP 
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
